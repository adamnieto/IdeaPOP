(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var ko = require('knockout');
require('mina');

module.exports = function(graph) {
  var self = this;
  this.element = ko.observable();
  this.previousGraph = undefined;
  this.element.subscribe(function(val) {
    if (val) self.animate(true);
  });
  this.animate = function(forceRefresh) {
    var currentGraph = this.getGraphAttr();
    // animate only when dom is valid and (attribute changed or force refresh due to dom change)
    if (this.element() && (forceRefresh || JSON.stringify(currentGraph) !== JSON.stringify(this.previousGraph))) {
      var now = Date.now();
      window.mina(this.previousGraph || currentGraph, currentGraph, now, now + 750, window.mina.time, function (val) {
        self.setGraphAttr(val);
      }, window.mina.elastic);
      this.previousGraph = currentGraph;
    }
  }
};

},{"knockout":"knockout","mina":undefined}],2:[function(require,module,exports){
var ko = require('knockout');
var Animateable = require('./animateable');

var EdgeViewModel = function(graph, nodeAsha1, nodeBsha1) {
  var self = this;
  Animateable.call(this);
  this.nodeA = graph.getNode(nodeAsha1);
  this.nodeB = graph.getNode(nodeBsha1);
  this.getGraphAttr = ko.computed(function() {
    if (self.nodeB.isInited && self.nodeB.cx() && self.nodeB.cy()) {
      return [self.nodeA.cx(), self.nodeA.cy(), self.nodeA.cx(), self.nodeA.cy(),
              self.nodeB.cx(), self.nodeB.cy(), self.nodeB.cx(), self.nodeB.cy()];
    } else if (graph.graphHeight()) {
      return [self.nodeA.cx(), self.nodeA.cy(), self.nodeA.cx(), self.nodeA.cy(),
              self.nodeA.cx(), graph.graphHeight(), self.nodeA.cx(), graph.graphHeight()];
    } else {
      return [self.nodeA.cx(), self.nodeA.cy(), self.nodeA.cx(), self.nodeA.cy(),
              self.nodeA.cx(), self.nodeA.cy(), self.nodeA.cx(), self.nodeA.cy()];
    }
  });
  this.getGraphAttr.subscribe(this.animate.bind(this));
}
EdgeViewModel.prototype.setGraphAttr = function(val) {
  this.element().setAttribute('d', 'M' + val.slice(0,4).join(',') + 'L' + val.slice(4,8).join(','));
}
module.exports = EdgeViewModel;

},{"./animateable":1,"knockout":"knockout"}],3:[function(require,module,exports){

var ko = require('knockout');
var inherits = require('util').inherits;
var components = require('ungit-components');
var RefViewModel = require('./git-ref.js');
var HoverActions = require('./hover-actions');
var RebaseViewModel = HoverActions.RebaseViewModel;
var MergeViewModel = HoverActions.MergeViewModel;
var ResetViewModel = HoverActions.ResetViewModel;
var PushViewModel = HoverActions.PushViewModel;
var programEvents = require('ungit-program-events');

var GraphActions = {};
module.exports = GraphActions;

GraphActions.ActionBase = function(graph) {
  var self = this;
  this.graph = graph;
  this.server = graph.server;
  this.performProgressBar = components.create('progressBar', {
    predictionMemoryKey: 'action-' + this.style + '-' + graph.repoPath,
    fallbackPredictedTimeMs: 1000,
    temporary: true
  });

  this.isHighlighted = ko.computed(function() {
    return !graph.hoverGraphAction() || graph.hoverGraphAction() == self;
  });
  this.cssClasses = ko.computed(function() {
    var c = self.style;
    if (!self.isHighlighted()) c += ' dimmed';
    return c;
  })
}
GraphActions.ActionBase.prototype.icon = null;
GraphActions.ActionBase.prototype.doPerform = function() {
  var self = this;
  this.graph.hoverGraphAction(null);
  self.performProgressBar.start();
  this.perform(function() {
    self.performProgressBar.stop();
  });
}
GraphActions.ActionBase.prototype.dragEnter = function() {
  if (!this.visible()) return;
  this.graph.hoverGraphAction(this);
}
GraphActions.ActionBase.prototype.dragLeave = function() {
  if (!this.visible()) return;
  this.graph.hoverGraphAction(null);
}
GraphActions.ActionBase.prototype.mouseover = function() {
  this.graph.hoverGraphAction(this);
}
GraphActions.ActionBase.prototype.mouseout = function() {
  this.graph.hoverGraphAction(null);
}

GraphActions.Move = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() != self.node;
  });
}
inherits(GraphActions.Move, GraphActions.ActionBase);
GraphActions.Move.prototype.text = 'Move';
GraphActions.Move.prototype.style = 'move';
GraphActions.Move.prototype.icon = 'glyphicon glyphicon-move';
GraphActions.Move.prototype.perform = function(callback) {
  this.graph.currentActionContext().moveTo(this.node.sha1, callback);
}

GraphActions.Reset = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    if (!(self.graph.currentActionContext() instanceof RefViewModel)) return false;
    var context = self.graph.currentActionContext();
    if (context.node() != self.node) return false;
    var remoteRef = context.getRemoteRef(self.graph.currentRemote());
    return remoteRef &&
      remoteRef.node() != context.node() &&
      remoteRef.node().date < context.node().date;
  });
}
inherits(GraphActions.Reset, GraphActions.ActionBase);
GraphActions.Reset.prototype.text = 'Reset';
GraphActions.Reset.prototype.style = 'reset';
GraphActions.Reset.prototype.icon = 'glyphicon glyphicon-trash';
GraphActions.Reset.prototype.createHoverGraphic = function() {
  var context = this.graph.currentActionContext();
  if (!context) return null;
  var remoteRef = context.getRemoteRef(this.graph.currentRemote());
  var nodes = context.node().getPathToCommonAncestor(remoteRef.node()).slice(0, -1);
  return new ResetViewModel(nodes);
}
GraphActions.Reset.prototype.perform = function(callback) {
  var self = this;
  var context = this.graph.currentActionContext();
  var diag = components.create('yesnodialog', { title: 'Are you sure?', details: 'This operation cannot be undone with ungit.'});
  diag.closed.add(function() {
    if (diag.result()) {
      var remoteRef = context.getRemoteRef(self.graph.currentRemote());
      self.server.post('/reset', { path: self.graph.repoPath, to: remoteRef.name, mode: 'hard' }, function() {
        context.node(remoteRef.node());
        callback();
      });
    } else {
      callback();
    }
  });
  programEvents.dispatch({ event: 'request-show-dialog', dialog: diag });
}

GraphActions.Rebase = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      (!ungit.config.showRebaseAndMergeOnlyOnRefs || self.node.refs().length > 0) &&
      self.graph.currentActionContext().current() &&
      self.graph.currentActionContext().node() != self.node;
  });
}
inherits(GraphActions.Rebase, GraphActions.ActionBase);
GraphActions.Rebase.prototype.text = 'Rebase';
GraphActions.Rebase.prototype.style = 'rebase';
GraphActions.Rebase.prototype.icon = 'octicon octicon-repo-forked flip';
GraphActions.Rebase.prototype.createHoverGraphic = function() {
  var onto = this.graph.currentActionContext();
  if (!onto) return;
  if (onto instanceof RefViewModel) onto = onto.node();
  var path = onto.getPathToCommonAncestor(this.node);
  return new RebaseViewModel(this.node, path);
}
GraphActions.Rebase.prototype.perform = function(callback) {
  this.server.post('/rebase', { path: this.graph.repoPath, onto: this.node.sha1 }, function(err) {
    callback();
    if (err && err.errorCode == 'merge-failed') return true;
  });
}

GraphActions.Merge = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    if (!self.graph.checkedOutRef() || !self.graph.checkedOutRef().node()) return false;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      !self.graph.currentActionContext().current() &&
      self.graph.checkedOutRef().node() == self.node;
  });
}
inherits(GraphActions.Merge, GraphActions.ActionBase);
GraphActions.Merge.prototype.text = 'Merge';
GraphActions.Merge.prototype.style = 'merge';
GraphActions.Merge.prototype.icon = 'octicon octicon-git-merge';
GraphActions.Merge.prototype.createHoverGraphic = function() {
  var node = this.graph.currentActionContext();
  if (!node) return null;
  if (node instanceof RefViewModel) node = node.node();
  return new MergeViewModel(this.graph, this.node, node);
}
GraphActions.Merge.prototype.perform = function(callback) {
  this.server.post('/merge', { path: this.graph.repoPath, with: this.graph.currentActionContext().localRefName }, function(err) {
    callback();
    if (err && err.errorCode == 'merge-failed') return true;
  });
}

GraphActions.Push = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() == self.node &&
      self.graph.currentActionContext().canBePushed(self.graph.currentRemote());
  });
}
inherits(GraphActions.Push, GraphActions.ActionBase);
GraphActions.Push.prototype.text = 'Push';
GraphActions.Push.prototype.style = 'push';
GraphActions.Push.prototype.icon = 'octicon octicon-cloud-upload';
GraphActions.Push.prototype.createHoverGraphic = function() {
  var context = this.graph.currentActionContext();
  if (!context) return null;
  var remoteRef = context.getRemoteRef(this.graph.currentRemote());
  if (!remoteRef) return null;
  return new PushViewModel(remoteRef.node(), context.node());
}
GraphActions.Push.prototype.perform = function(callback) {
  var self = this;
  var ref = this.graph.currentActionContext();
  var remoteRef = ref.getRemoteRef(this.graph.currentRemote());

  if (remoteRef) {
    remoteRef.moveTo(ref.node().sha1, callback);
  } else ref.createRemoteRef(function(err) {
    if (!err && self.graph.HEAD().name == ref.name) {
      self.grah.HEADref().node(ref.node());
    }
    callback();
  });
}

GraphActions.Checkout = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    if (self.graph.currentActionContext() instanceof RefViewModel)
      return self.graph.currentActionContext().node() == self.node &&
        !self.graph.currentActionContext().current();
    return ungit.config.allowCheckoutNodes &&
      self.graph.currentActionContext() == self.node;
  });
}
inherits(GraphActions.Checkout, GraphActions.ActionBase);
GraphActions.Checkout.prototype.text = 'Checkout';
GraphActions.Checkout.prototype.style = 'checkout';
GraphActions.Checkout.prototype.icon = 'octicon octicon-desktop-download';
GraphActions.Checkout.prototype.perform = function(callback) {
  var self = this;
  var context = this.graph.currentActionContext();
  var refName = context instanceof RefViewModel ? context.refName : context.sha1;
  this.server.post('/checkout', { path: this.graph.repoPath, name: refName }, function(err) {
    if (err && err.errorCode != 'merge-failed') {
      callback();
      return;
    }

    if (context instanceof RefViewModel && context.isRemoteBranch) {
      self.server.post('/reset', { path: self.graph.repoPath, to: context.name, mode: 'hard' }, function(err, res) {
        self.graph.HEADref().node(context instanceof RefViewModel ? context.node() : context);
        callback();
        return err && err.errorCode != 'merge-failed' ? undefined : true;
      });
    } else {
      self.graph.HEADref().node(context instanceof RefViewModel ? context.node() : context);
      callback();
    }
    return true;
  });
}

GraphActions.Delete = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() == self.node &&
      !self.graph.currentActionContext().current();
  });
}
inherits(GraphActions.Delete, GraphActions.ActionBase);
GraphActions.Delete.prototype.text = 'Delete';
GraphActions.Delete.prototype.style = 'delete';
GraphActions.Delete.prototype.icon = 'glyphicon glyphicon-remove';
GraphActions.Delete.prototype.perform = function(callback) {
  var context = this.graph.currentActionContext();
  var diag = components.create('yesnodialog', { title: 'Are you sure?', details: 'This operation cannot be undone with ungit.'});
  diag.closed.add(function() {
    if (diag.result()) {
      context.remove(callback);
    } else {
      callback();
    }
  });
  programEvents.dispatch({ event: 'request-show-dialog', dialog: diag });
}

GraphActions.CherryPick = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() == self.node
  });
}
inherits(GraphActions.CherryPick, GraphActions.ActionBase);
GraphActions.CherryPick.prototype.text = 'Cherry pick';
GraphActions.CherryPick.prototype.style = 'cherry-pick';
GraphActions.CherryPick.prototype.icon = 'octicon octicon-circuit-board';
GraphActions.CherryPick.prototype.perform = function(callback) {
  var self = this;
  this.server.post('/cherrypick', { path: this.graph.repoPath, name: this.node.sha1 }, function(err) {
    callback();
    if (err && err.errorCode == 'merge-failed') return true;
  });
}

GraphActions.Uncommit = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() == self.node &&
      self.graph.HEAD() == self.node;
  });
}
inherits(GraphActions.Uncommit, GraphActions.ActionBase);
GraphActions.Uncommit.prototype.text = 'Uncommit';
GraphActions.Uncommit.prototype.style = 'uncommit';
GraphActions.Uncommit.prototype.icon = 'octicon octicon-zap';
GraphActions.Uncommit.prototype.perform = function(callback) {
  var self = this;
  this.server.postPromise('/reset', { path: this.graph.repoPath, to: 'HEAD^', mode: 'mixed' })
    .then(function() {
      var targetNode = self.node.belowNode;
      while (targetNode && !targetNode.ancestorOfHEAD()) {
        targetNode = targetNode.belowNode;
      }
      self.graph.HEADref().node(targetNode ? targetNode : null);
      self.graph.checkedOutRef().node(targetNode ? targetNode : null);
    }).finally(callback);
}

GraphActions.Revert = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() == self.node;
  });
}
inherits(GraphActions.Revert, GraphActions.ActionBase);
GraphActions.Revert.prototype.text = 'Revert';
GraphActions.Revert.prototype.style = 'revert';
GraphActions.Revert.prototype.icon = 'octicon octicon-history';
GraphActions.Revert.prototype.perform = function(callback) {
  var self = this;
  this.server.postPromise('/revert', { path: this.graph.repoPath, commit: this.node.sha1 })
    .finally(callback);
}

},{"./git-ref.js":5,"./hover-actions":7,"knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events","util":undefined}],4:[function(require,module,exports){
var ko = require('knockout');
var components = require('ungit-components');
var Selectable = require('./selectable');
var Animateable = require('./animateable');
var programEvents = require('ungit-program-events');
var GraphActions = require('./git-graph-actions');

var GitNodeViewModel = function(graph, sha1) {
  var self = this;
  Selectable.call(this, graph);
  Animateable.call(this);
  this.graph = graph;
  this.sha1 = sha1;
  this.isInited = false;
  this.title = undefined;
  this.parents = ko.observableArray();
  this.commitTime = undefined; // commit time in string
  this.date = undefined;       // commit time in numeric format for sort
  this.color = ko.observable();
  this.ideologicalBranch = ko.observable();
  this.remoteTags = ko.observableArray();
  this.branchesAndLocalTags = ko.observableArray();

  this.refs = ko.computed(function() {
    var rs = self.branchesAndLocalTags().concat(self.remoteTags());
    rs.sort(function(a, b) {
      if (a.isLocal && !b.isLocal) return -1;
      if (!a.isLocal && b.isLocal) return 1;
      return a.refName < b.refName ? -1 : 1;
    });
    return rs;
  });
  this.ancestorOfHEAD = ko.observable(false);
  this.nodeIsMousehover = ko.observable(false);
  this.commitContainerVisible = ko.computed(function() {
    return self.ancestorOfHEAD() || self.nodeIsMousehover() || self.selected();
  });
  this.highlighted = ko.computed(function() {
    return self.nodeIsMousehover() || self.selected();
  });
  this.selected.subscribe(function() {
    programEvents.dispatch({ event: 'graph-render' });
  });
  this.commitComponent = components.create('commit', {
    sha1: this.sha1,
    repoPath: this.graph.repoPath,
    server: this.graph.server,
    selected: this.selected,
    highlighted: this.highlighted,
    nodeIsMousehover: this.nodeIsMousehover
  });
  // These are split up like this because branches and local tags can be found in the git log,
  // whereas remote tags needs to be fetched with another command (which is much slower)
  this.branches = ko.computed(function() {
    return self.refs().filter(function(r) { return r.isBranch; });
  });
  this.tags = ko.computed(function() {
    return self.refs().filter(function(r) { return r.isTag; });
  });
  this.showNewRefAction = ko.computed(function() {
    return !graph.currentActionContext();
  });
  this.newBranchName = ko.observable();
  this.newBranchNameHasFocus = ko.observable(true);
  this.newBranchNameHasFocus.subscribe(function(newValue) {
    if (!newValue) {
      // Small timeout because in ff the form is hidden before the submit click event is registered otherwise
      setTimeout(function() {
        self.branchingFormVisible(false);
      }, 200);
    }
  });
  this.branchingFormVisible = ko.observable(false);
  this.canCreateRef = ko.computed(function() {
    return self.newBranchName() && self.newBranchName().trim() && self.newBranchName().indexOf(' ') == -1;
  });
  this.branchOrder = ko.observable();
  this.aboveNode = undefined;
  this.belowNode = undefined;

  this.r = ko.observable();
  this.cx = ko.observable();
  this.cy = ko.observable();

  this.dropareaGraphActions = [
    new GraphActions.Move(this.graph, this),
    new GraphActions.Rebase(this.graph, this),
    new GraphActions.Merge(this.graph, this),
    new GraphActions.Push(this.graph, this),
    new GraphActions.Reset(this.graph, this),
    new GraphActions.Checkout(this.graph, this),
    new GraphActions.Delete(this.graph, this),
    new GraphActions.CherryPick(this.graph, this),
    new GraphActions.Uncommit(this.graph, this),
    new GraphActions.Revert(this.graph, this)
  ];
}
module.exports = GitNodeViewModel;

GitNodeViewModel.prototype.getGraphAttr = function() {
  return [this.cx(), this.cy()];
}
GitNodeViewModel.prototype.setGraphAttr = function(val) {
  this.element().setAttribute('x', val[0] - 30);
  this.element().setAttribute('y', val[1] - 30);
}
GitNodeViewModel.prototype.render = function() {
  if (!this.isInited) return;
  if (this.ancestorOfHEAD()) {
    this.r(30);
    this.cx(610);

    if (!this.aboveNode) {
      this.cy(120);
    } else if (this.aboveNode.ancestorOfHEAD()) {
      this.cy(this.aboveNode.cy() + 120);
    } else {
      this.cy(this.aboveNode.cy() + 60);
    }
  } else {
    this.r(15);
    this.cx(610 + (90 * this.branchOrder()));
    this.cy(this.aboveNode ? this.aboveNode.cy() + 60 : 120);
  }

  if (this.aboveNode && this.aboveNode.selected()) {
    this.cy(this.aboveNode.cy() + this.aboveNode.commitComponent.element().offsetHeight + 30);
  }

  this.commitComponent.selectedDiffLeftPosition(-(this.cx() - 600));
  this.color(this.ideologicalBranch() ? this.ideologicalBranch().color : '#666');
  this.animate();
}
GitNodeViewModel.prototype.setData = function(logEntry) {
  var self = this;
  this.title = logEntry.message.split('\n')[0];
  this.parents(logEntry.parents || []);
  this.commitTime = logEntry.commitDate;
  this.date = Date.parse(this.commitTime);
  this.commitComponent.setData(logEntry);

  if (logEntry.refs) {
    var refVMs = logEntry.refs.map(function(ref) {
      var refViewModel = self.graph.getRef(ref);
      refViewModel.node(self);
      return refViewModel;
    });
    this.branchesAndLocalTags(refVMs);
  }

  this.isInited = true;
}
GitNodeViewModel.prototype.showBranchingForm = function() {
  this.branchingFormVisible(true);
  this.newBranchNameHasFocus(true);
}
GitNodeViewModel.prototype.createBranch = function() {
  if (!this.canCreateRef()) return;
  var self = this;
  this.graph.server.postPromise('/branches', { path: this.graph.repoPath, name: this.newBranchName(), startPoint: this.sha1 })
    .then(function() {
      var newRef = self.graph.getRef('refs/heads/' + self.newBranchName());
      newRef.node(self);
      self.branchesAndLocalTags.push(newRef);
    }).finally(function() {
      self.branchingFormVisible(false);
      self.newBranchName('');
      programEvents.dispatch({ event: 'branch-updated' });
    });
}
GitNodeViewModel.prototype.createTag = function() {
  if (!this.canCreateRef()) return;
  var self = this;
  this.graph.server.postPromise('/tags', { path: this.graph.repoPath, name: this.newBranchName(), startPoint: this.sha1 })
    .then(function() {
      var newRef = self.graph.getRef('tag: refs/tags/' + self.newBranchName());
      newRef.node(self);
      self.branchesAndLocalTags.push(newRef);
    }).finally(function() {
      self.branchingFormVisible(false);
      self.newBranchName('');
    });
}
GitNodeViewModel.prototype.toggleSelected = function() {
  var self = this;
  var beforeThisCR = this.commitComponent.element().getBoundingClientRect();
  var beforeBelowCR = null;
  if (this.belowNode) {
    beforeBelowCR = this.belowNode.commitComponent.element().getBoundingClientRect();
  }

  var prevSelected  = this.graph.currentActionContext();
  if (!(prevSelected instanceof GitNodeViewModel)) prevSelected = null;
  var prevSelectedCR = prevSelected ? prevSelected.commitComponent.element().getBoundingClientRect() : null;
  this.selected(!this.selected());

  // If we are deselecting
  if (!this.selected()) {
    if (beforeThisCR.top < 0 && beforeBelowCR) {
      var afterBelowCR = this.belowNode.commitComponent.element().getBoundingClientRect();
      // If the next node is showing, try to keep it in the screen (no jumping)
      if (beforeBelowCR.top < window.innerHeight) {
        window.scrollBy(0, afterBelowCR.top - beforeBelowCR.top);
      // Otherwise just try to bring them to the middle of the screen
      } else {
        window.scrollBy(0, afterBelowCR.top - window.innerHeight / 2);
      }
    }
  // If we are selecting
  } else {
    var afterThisCR = this.commitComponent.element().getBoundingClientRect();
    if ((prevSelectedCR && (prevSelectedCR.top < 0 || prevSelectedCR.top > window.innerHeight)) &&
      afterThisCR.top != beforeThisCR.top) {
      window.scrollBy(0, -(beforeThisCR.top - afterThisCR.top));
      console.log('Fix')
    }
  }
  return false;
}
GitNodeViewModel.prototype.removeRef = function(ref) {
  if (ref.isRemoteTag) {
    this.remoteTags.remove(ref);
  } else {
    this.branchesAndLocalTags.remove(ref);
  }
}
GitNodeViewModel.prototype.pushRef = function(ref) {
  if (ref.isRemoteTag) {
    this.remoteTags.push(ref);
  } else {
    this.branchesAndLocalTags.push(ref);
  }
}
GitNodeViewModel.prototype.getPathToCommonAncestor = function(node) {
  var path = [];
  var thisNode = this;
  while (thisNode && !node.isAncestor(thisNode)) {
    path.push(thisNode);
    thisNode = this.graph.nodesById[thisNode.parents()[0]];
  }
  if (thisNode) path.push(thisNode);
  return path;
}
GitNodeViewModel.prototype.isAncestor = function(node) {
  if (node == this) return true;
  for (var v in this.parents()) {
    var n = this.graph.nodesById[this.parents()[v]];
    if (n && n.isAncestor(node)) return true;
  }
  return false;
}
GitNodeViewModel.prototype.getRightToLeftStrike = function() {
  return 'M ' + (this.cx() - 30) + ' ' + (this.cy() - 30) + ' L ' + (this.cx() + 30) + ' ' + (this.cy() + 30);
}
GitNodeViewModel.prototype.getLeftToRightStrike = function() {
  return 'M ' + (this.cx() + 30) + ' ' + (this.cy() - 30) + ' L ' + (this.cx() - 30) + ' ' + (this.cy() + 30);
}
GitNodeViewModel.prototype.nodeMouseover = function() {
  this.nodeIsMousehover(true);
}
GitNodeViewModel.prototype.nodeMouseout = function() {
  this.nodeIsMousehover(false);
}

},{"./animateable":1,"./git-graph-actions":3,"./selectable":8,"knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}],5:[function(require,module,exports){
var ko = require('knockout');
var md5 = require('blueimp-md5');
var Selectable = require('./selectable');
var programEvents = require('ungit-program-events');
var components = require('ungit-components');

var RefViewModel = function(fullRefName, graph) {
  var self = this;
  Selectable.call(this, graph);
  this.graph = graph;
  this.name = fullRefName;
  this.node = ko.observable();
  this.localRefName = this.name; // origin/master or master
  this.refName = this.name; // master
  this.isRemoteTag = this.name.indexOf('remote-tag: ') == 0;
  this.isLocalTag = this.name.indexOf('tag: ') == 0;
  this.isTag = this.isLocalTag || this.isRemoteTag;
  var isRemoteBranchOrHEAD = this.name.indexOf('refs/remotes/') == 0;
  this.isLocalHEAD = this.name == 'HEAD';
  this.isRemoteHEAD = this.name.indexOf('/HEAD') != -1;
  this.isLocalBranch = this.name.indexOf('refs/heads/') == 0;
  this.isRemoteBranch = isRemoteBranchOrHEAD && !this.isRemoteHEAD;
  this.isStash = this.name.indexOf('refs/stash') == 0;
  this.isHEAD = this.isLocalHEAD || this.isRemoteHEAD;
  this.isBranch = this.isLocalBranch || this.isRemoteBranch;
  this.isRemote = isRemoteBranchOrHEAD || this.isRemoteTag;
  this.isLocal = this.isLocalBranch || this.isLocalTag;
  if (this.isLocalBranch) {
    this.localRefName = this.name.slice('refs/heads/'.length);
    this.refName = this.localRefName;
  }
  if (this.isRemoteBranch) {
    this.localRefName = this.name.slice('refs/remotes/'.length);
  }
  if (this.isLocalTag) {
    this.localRefName = this.name.slice('tag: refs/tags/'.length);
    this.refName = this.localRefName;
  }
  if (this.isRemoteTag) {
    this.localRefName = this.name.slice('remote-tag: '.length);
  }
  if (this.isRemote) {
    // get rid of the origin/ part of origin/branchname
    var s = this.localRefName.split('/');
    this.remote = s[0];
    this.refName = s.slice(1).join('/');
  }
  this.show = true;
  this.server = this.graph.server;
  this.isDragging = ko.observable(false);
  this.current = ko.computed(function() {
    return self.isLocalBranch && self.graph.checkedOutBranch() == self.refName;
  });
  this.color = this._colorFromHashOfString(this.name);

  this.node.subscribe(function(oldNode) {
    if (oldNode) oldNode.branchesAndLocalTags.remove(self);
  }, null, "beforeChange");
  this.node.subscribe(function(newNode) {
    if (newNode) newNode.branchesAndLocalTags.push(self);
  })
};
module.exports = RefViewModel;

RefViewModel.prototype._colorFromHashOfString = function(string) {
  return '#' + md5(string).toString().slice(0, 6);
}
RefViewModel.prototype.dragStart = function() {
  this.graph.currentActionContext(this);
  this.isDragging(true);
  if (document.activeElement) document.activeElement.blur();
}
RefViewModel.prototype.dragEnd = function() {
  this.graph.currentActionContext(null);
  this.isDragging(false);
}
RefViewModel.prototype.moveTo = function(target, callback) {
  var self = this;

  var callbackWithRefSet = function(err, res) {
    if (err) {
      callback(err, res);
    } else {
      var targetNode = self.graph.getNode(target);
      if (self.graph.checkedOutBranch() == self.refName) {
        self.graph.HEADref().node(targetNode);
      }
      self.node(targetNode);
      callback();
    }
  }

  if (this.isLocal) {
    if (this.current()) {
      this.server.post('/reset', { path: this.graph.repoPath, to: target, mode: 'hard' }, callbackWithRefSet);
    } else if (this.isTag) {
      this.server.post('/tags', { path: this.graph.repoPath, name: this.refName, startPoint: target, force: true }, callbackWithRefSet);
    } else {
      this.server.post('/branches', { path: this.graph.repoPath, name: this.refName, startPoint: target, force: true }, callbackWithRefSet);
    }
  } else {
    var pushReq = { path: this.graph.repoPath, remote: this.remote, refSpec: target, remoteBranch: this.refName };
    this.server.post('/push', pushReq, function(err, res) {
        if (err) {
          if (err.errorCode == 'non-fast-forward') {
            var forcePushDialog = components.create('yesnodialog', { title: 'Force push?', details: 'The remote branch can\'t be fast-forwarded.' });
            forcePushDialog.closed.add(function() {
              if (!forcePushDialog.result()) return callback();
              pushReq.force = true;
              self.server.post('/push', pushReq, callbackWithRefSet);
            });
            programEvents.dispatch({ event: 'request-show-dialog', dialog: forcePushDialog });
            return true;
          }
        }
        callbackWithRefSet(err, res);
      });
  }
}

RefViewModel.prototype.remove = function(callback) {
  var self = this;
  var url = this.isTag ? '/tags' : '/branches';
  if (this.isRemote) url = '/remote' + url;
  this.server.del(url, { path: this.graph.repoPath, remote: this.isRemote ? this.remote : null, name: this.refName }, function(err) {
    if (!err) {
      self.node().removeRef(self);
      self.graph.refsByRefName[self.name] = undefined;
    }

    callback();
    self.graph.loadNodesFromApi();
    if (url == '/remote/tags') {
      programEvents.dispatch({ event: 'request-fetch-tags' });
    } else {
      programEvents.dispatch({ event: 'branch-updated' });
    }
  });
}

RefViewModel.prototype.getRemoteRef = function(remote) {
  return this.graph.getRef(this.getRemoteRefFullName(remote), false);
}

RefViewModel.prototype.getRemoteRefFullName = function(remote) {
  if (this.isLocalBranch) return 'refs/remotes/' + remote + '/' + this.refName;
  if (this.isLocalTag) return 'remote-tag: ' + remote + '/' + this.refName;
  return null;
}

RefViewModel.prototype.canBePushed = function(remote) {
  if (!this.isLocal) return false;
  var remoteRef = this.getRemoteRef(remote);
  if (!remoteRef) return true;
  return this.node() != remoteRef.node();
}

RefViewModel.prototype.createRemoteRef = function(callback) {
  var self = this;
  this.server.post('/push', { path: this.graph.repoPath, remote: this.graph.currentRemote(),
      refSpec: this.refName, remoteBranch: this.refName }, function(err) {
        if (!err) {
          var newRef = self.graph.getRef("refs/remotes/" + self.graph.currentRemote() + "/" + self.refName);
          self.node().branchesAndLocalTags.push(newRef);
          newRef.node(self.node());
        }
        callback(err);
      });
}

},{"./selectable":8,"blueimp-md5":"blueimp-md5","knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}],6:[function(require,module,exports){
var ko = require('knockout');
var components = require('ungit-components');
var GitNodeViewModel = require('./git-node');
var GitRefViewModel = require('./git-ref');
var _ = require('lodash');
var moment = require('moment');
var EdgeViewModel = require('./edge');

components.register('graph', function(args) {
  return new GraphViewModel(args.server, args.repoPath);
});

function GraphViewModel(server, repoPath) {
  var self = this;
  this.repoPath = repoPath;
  this.maxNNodes = 25;
  this.server = server;
  this.currentRemote = ko.observable();
  this.nodesLoader = components.create('progressBar', {
    predictionMemoryKey: 'gitgraph-' + self.repoPath,
    fallbackPredictedTimeMs: 1000,
    temporary: true
  });
  this.nodes = ko.observableArray();
  this.edges = ko.observableArray();
  this.refs = ko.observableArray();
  this.nodesById = {};
  this.refsByRefName = {};
  this.checkedOutBranch = ko.observable();
  this.checkedOutRef = ko.computed(function() {
    return self.checkedOutBranch() ? self.getRef('refs/heads/' + self.checkedOutBranch()) : null;
  });
  this.HEADref = ko.observable();
  this.HEAD = ko.computed(function() {
    return self.HEADref() ? self.HEADref().node() : undefined;
  });
  this.commitNodeColor = ko.computed(function() {
    return self.HEAD() ? self.HEAD().color() : '#4A4A4A';
  });
  this.commitNodeEdge = ko.computed(function() {
    if (!self.HEAD() || !self.HEAD().cx() || !self.HEAD().cy()) return;
    return "M 610 68 L " + self.HEAD().cx() + " " + self.HEAD().cy();
  });
  this.showCommitNode = ko.observable(false);
  this.currentActionContext = ko.observable();
  this.edgesById = {};
  this.scrolledToEnd = _.debounce(function() {
    self.maxNNodes = self.maxNNodes + 25;
    self.loadNodesFromApi();
  }, 500, true);
  this.dimCommit = ko.observable(false);
  this.commitOpacity = ko.computed(function() { return self.dimCommit() ? 0.1 : 1; });
  this.heighstBranchOrder = 0;
  this.hoverGraphActionGraphic = ko.observable();
  this.hoverGraphActionGraphic.subscribe(function(value) {
    if (value && value.destroy)
      value.destroy();
  }, null, 'beforeChange');

  this.hoverGraphAction = ko.observable();
  this.hoverGraphAction.subscribe(function(value) {
    if (value && value.createHoverGraphic) {
      self.hoverGraphActionGraphic(value.createHoverGraphic());
    } else {
      self.hoverGraphActionGraphic(null);
    }
  });

  this.loadNodesFromApiThrottled = _.throttle(this.loadNodesFromApi.bind(this), 500);
  this.updateBranchesThrottled = _.throttle(this.updateBranches.bind(this), 500);
  this.loadNodesFromApiThrottled();
  this.updateBranchesThrottled();
  this.graphWidth = ko.observable();
  this.graphHeight = ko.observable();
}

GraphViewModel.prototype.updateNode = function(parentElement) {
  ko.renderTemplate('graph', this, {}, parentElement);
}

GraphViewModel.prototype.getNode = function(sha1, logEntry) {
  var nodeViewModel = this.nodesById[sha1];
  if (!nodeViewModel) nodeViewModel = this.nodesById[sha1] = new GitNodeViewModel(this, sha1);
  if (logEntry) nodeViewModel.setData(logEntry);
  return nodeViewModel;
}
GraphViewModel.prototype.getRef = function(ref, constructIfUnavailable) {
  if (constructIfUnavailable === undefined) constructIfUnavailable = true;
  var refViewModel = this.refsByRefName[ref];
  if (!refViewModel && constructIfUnavailable) {
    refViewModel = this.refsByRefName[ref] = new GitRefViewModel(ref, this);
    this.refs.push(refViewModel);
    if (refViewModel.name === 'HEAD') {
      this.HEADref(refViewModel);
    }
  }
  return refViewModel;
}

GraphViewModel.prototype.loadNodesFromApi = function(callback) {
  var self = this;

  this.nodesLoader.start();
  this.server.getPromise('/log', { path: this.repoPath, limit: this.maxNNodes })
    .then(function(nodes) {
      nodes = self.computeNode(nodes.map(function(logEntry) {
          return self.getNode(logEntry.sha1, logEntry);
        }));

      var edges = [];
      nodes.forEach(function(node) {
        node.parents().forEach(function(parentSha1) {
          edges.push(self.getEdge(node.sha1, parentSha1));
        });
        node.render();
      });

      self.edges(edges);
      self.nodes(nodes);

      if (nodes.length > 0) {
        self.graphHeight(nodes[nodes.length - 1].cy() + 80);
      }
      self.graphWidth(1000 + (self.heighstBranchOrder * 90));
    }).finally(function() {
      self.nodesLoader.stop();
      if (callback) callback();
    });
}

GraphViewModel.prototype.traverseNodeLeftParents = function(node, callback) {
  callback(node);
  var parent = this.nodesById[node.parents()[0]];
  if (parent) {
    this.traverseNodeLeftParents(parent, callback);
  }
}

GraphViewModel.prototype.computeNode = function(nodes) {
  var self = this;

  if (!nodes) {
    nodes = this.nodes();
  }

  this.markNodesIdeologicalBranches(this.refs(), nodes, this.nodesById);

  var updateTimeStamp = moment().valueOf();
  if (this.HEAD()) {
    this.traverseNodeLeftParents(this.HEAD(), function(node) {
      node.ancestorOfHEADTimeStamp = updateTimeStamp;
    });
  }

  // Filter out nodes which doesn't have a branch (staging and orphaned nodes)
  nodes = nodes.filter(function(node) { return (node.ideologicalBranch() && !node.ideologicalBranch().isStash) || node.ancestorOfHEADTimeStamp == updateTimeStamp; })

  var branchSlots = [];

  // Then iterate from the bottom to fix the orders of the branches
  for (var i = nodes.length - 1; i >= 0; i--) {
    var node = nodes[i];
    if (node.ancestorOfHEADTimeStamp == updateTimeStamp) continue;
    var ideologicalBranch = node.ideologicalBranch();

    // First occurence of the branch, find an empty slot for the branch
    if (ideologicalBranch.lastSlottedTimeStamp != updateTimeStamp) {
      ideologicalBranch.lastSlottedTimeStamp = updateTimeStamp;
      var slot = branchSlots.indexOf(undefined);
      if (slot === -1) {
        branchSlots.push(ideologicalBranch);
        slot = branchSlots.length - 1;
      }
      ideologicalBranch.branchOrder = slot;
      branchSlots[slot] = slot;
    }

    node.branchOrder(ideologicalBranch.branchOrder);
    self.heighstBranchOrder = Math.max(self.heighstBranchOrder, node.branchOrder());
  }

  var prevNode;
  nodes.forEach(function(node) {
    node.branchOrder(branchSlots.length - node.branchOrder());
    node.ancestorOfHEAD(node.ancestorOfHEADTimeStamp == updateTimeStamp);
    node.aboveNode = prevNode;
    if (prevNode) prevNode.belowNode = node;
    prevNode = node;
  });

  return nodes;
}

GraphViewModel.prototype.getEdge = function(nodeAsha1, nodeBsha1) {
  var id = nodeAsha1 + '-' + nodeBsha1;
  var edge = this.edgesById[id];
  if (!edge) {
    edge = this.edgesById[id] = new EdgeViewModel(this, nodeAsha1, nodeBsha1);
  }
  return edge;
}

GraphViewModel._markIdeologicalStamp = 0;
GraphViewModel.prototype.markNodesIdeologicalBranches = function(refs, nodes, nodesById) {
  var self = this;
  refs = refs.filter(function(r) { return !!r.node(); });
  refs = refs.sort(function(a, b) {
    if (a.isLocal && !b.isLocal) return -1;
    if (b.isLocal && !a.isLocal) return 1;
    if (a.isBranch && !b.isBranch) return -1;
    if (b.isBranch && !a.isBranch) return 1;
    if (a.isHEAD && !b.isHEAD) return 1;
    if (!a.isHEAD && b.isHEAD) return -1;
    if (a.isStash && !b.isStash) return 1;
    if (b.isStash && !a.isStash) return -1;
    if (a.node() && a.node().date && b.node() && b.node().date)
      return b.node().date - a.node().date;
    return a.refName < b.refName ? -1 : 1;
  });
  var stamp = GraphViewModel._markIdeologicalStamp++;
  refs.forEach(function(ref) {
    self.traverseNodeParents(ref.node(), function(node) {
      if (node.stamp == stamp) return false;
      node.stamp = stamp;
      node.ideologicalBranch(ref);
      return true;
    });
  });
}

GraphViewModel.prototype.traverseNodeParents = function(node, callback) {
  if (!callback(node)) return false;
  for (var i = 0; i < node.parents().length; i++) {
    // if parent, travers parent
    var parent = this.nodesById[node.parents()[i]];
    if (parent) {
      this.traverseNodeParents(parent, callback);
    }
  }
}

GraphViewModel.prototype.handleBubbledClick = function(elem, event) {
  // If the clicked element is bound to the current action context,
  // then let's not deselect it.
  if (ko.dataFor(event.target) === this.currentActionContext()) return;
  if (this.currentActionContext() && this.currentActionContext() instanceof GitNodeViewModel) {
    this.currentActionContext().toggleSelected();
  } else {
    this.currentActionContext(null);
  }
  // If the click was on an input element, then let's allow the default action to proceed.
  // This is especially needed since for some strange reason any submit (ie. enter in a textbox)
  // will trigger a click event on the submit input of the form, which will end up here,
  // and if we don't return true, then the submit event is never fired, breaking stuff.
  if (event.target.nodeName === 'INPUT') return true;
}

GraphViewModel.prototype.onProgramEvent = function(event) {
  if (event.event == 'git-directory-changed') {
    this.loadNodesFromApiThrottled();
    this.updateBranchesThrottled();
  } else if (event.event == 'request-app-content-refresh') {
    this.loadNodesFromApiThrottled();
  } else if (event.event == 'remote-tags-update') {
    this.setRemoteTags(event.tags);
  } else if (event.event == 'current-remote-changed') {
    this.currentRemote(event.newRemote);
  } else if (event.event == 'graph-render') {
    this.nodes().forEach(function(node) {
      node.render();
    });
  }
}
GraphViewModel.prototype.updateBranches = function() {
  var self = this;
  this.server.get('/checkout', { path: this.repoPath }, function(err, branch) {
    if (err && err.errorCode == 'not-a-repository') return true;
    if (err) return;
    self.checkedOutBranch(branch);
  });
}
GraphViewModel.prototype.setRemoteTags = function(remoteTags) {
  var self = this;
  var nodeIdsToRemoteTags = {};
  remoteTags.forEach(function(ref) {
    if (ref.name.indexOf('^{}') != -1) {
      var tagRef = ref.name.slice(0, ref.name.length - '^{}'.length);
      var name = 'remote-tag: ' + ref.remote + '/' + tagRef.split('/')[2];
      var refViewModel = self.getRef(name);
      var node = self.getNode(ref.sha1);
      refViewModel.node(node);

      nodeIdsToRemoteTags[ref.sha1] = nodeIdsToRemoteTags[ref.sha1] || [];
      nodeIdsToRemoteTags[ref.sha1].push(refViewModel);
    }
  });

  for(var key in this.nodesById) {
    this.nodesById[key].remoteTags(nodeIdsToRemoteTags[key] || []);
  }
}
GraphViewModel.prototype.checkHeadMove = function(toNode) {
  if (this.HEAD() === toNode) {
    this.HEADref.node(toNode);
  }
}

},{"./edge":2,"./git-node":4,"./git-ref":5,"knockout":"knockout","lodash":"lodash","moment":"moment","ungit-components":"ungit-components"}],7:[function(require,module,exports){
var getEdgeModelWithD = function(d, stroke, strokeWidth, strokeDasharray, markerEnd) {
  return { d: d,
          stroke: stroke ? stroke : '#4A4A4A',
          strokeWidth: strokeWidth ? strokeWidth : '8',
          strokeDasharray: strokeDasharray ? strokeDasharray : '10, 5',
          markerEnd: markerEnd ? markerEnd : '' };
}

var getEdgeModel = function(scx, scy, tcx, tcy, stroke, strokeWidth, strokeDasharray, markerEnd) {
  return getEdgeModelWithD("M " + scx + " " + scy + " L " + tcx + " " + tcy, stroke, strokeWidth, strokeDasharray, markerEnd);
}

var getNodeModel = function(cx, cy, r, fill, stroke, strokeWidth, strokeDasharray) {
  return { cx: cx,
          cy: cy,
          r: r,
          fill: fill,
          stroke: stroke ? stroke : '#41DE3C',
          strokeWidth: strokeWidth ? strokeWidth : '8',
          strokeDasharray: strokeDasharray ? strokeDasharray : '10, 5' };
}

function HoverViewModel() {
  this.bgEdges = [];
  this.nodes = [];
  this.fgEdges = [];
}

function MergeViewModel(graph, headNode, node) {
  var self = this;
  HoverViewModel.call(this);
  this.graph = graph;
  this.bgEdges = [ getEdgeModel(headNode.cx(), (headNode.cy() - 110), headNode.cx(), headNode.cy()),
                getEdgeModel(headNode.cx(), (headNode.cy() - 110), node.cx(), node.cy()) ];
  this.nodes = [ getNodeModel(headNode.cx(), headNode.cy() - 110, Math.max(headNode.r(), node.r()), '#252833', '#41DE3C', '8', '10, 5') ];

  graph.dimCommit(true);
}
exports.MergeViewModel = MergeViewModel;
MergeViewModel.prototype.destroy = function() {
  this.graph.dimCommit(false);
}

function RebaseViewModel(onto, nodesThatWillMove) {
  var self = this;
  HoverViewModel.call(this);
  nodesThatWillMove = nodesThatWillMove.slice(0, -1);

  if (nodesThatWillMove.length == 0) return;

  this.bgEdges.push(getEdgeModel(onto.cx(), onto.cy(), onto.cx(), onto.cy() - 60));
  nodesThatWillMove.forEach(function(node, i) {
    var cy = onto.cy() + (-90 * (i + 1));
    self.nodes.push(getNodeModel(onto.cx(), cy, 28, 'transparent'));
    if (i + 1 < nodesThatWillMove.length) {
      self.bgEdges.push(getEdgeModel(onto.cx(), (cy - 25), onto.cx(), (cy - 65)));
    }
  });
}
exports.RebaseViewModel = RebaseViewModel;

function ResetViewModel(nodes) {
  var self = this;
  HoverViewModel.call(this);

  nodes.forEach(function(node) {
    self.fgEdges.push(getEdgeModelWithD(node.getLeftToRightStrike(), 'rgb(255, 129, 31)', '8', '0, 0'))
    self.fgEdges.push(getEdgeModelWithD(node.getRightToLeftStrike(), 'rgb(255, 129, 31)', '8', '0, 0'));
  });
}
exports.ResetViewModel = ResetViewModel;

function PushViewModel(fromNode, toNode) {
  HoverViewModel.call(this);
  this.fgEdges = [getEdgeModel(fromNode.cx(), fromNode.cy(), toNode.cx(), (toNode.cy() + 40), 'rgb(61, 139, 255)', '15', '10, 5', 'url(#pushArrowEnd)' )];
}
exports.PushViewModel = PushViewModel;

},{}],8:[function(require,module,exports){
var ko = require('knockout');

var Selectable = function(graph) {
  this.selected = ko.computed({
    read: function() {
      return graph.currentActionContext() == this;
    },
    write: function(val) {
      // val is this if we're called from a click ko binding
      if (val === this || val === true) {
        graph.currentActionContext(this);
      } else if (graph.currentActionContext() == this) {
        graph.currentActionContext(null);
      }
    },
    owner: this
  });
};
module.exports = Selectable;

},{"knockout":"knockout"}]},{},[6])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL2dyYXBoL2FuaW1hdGVhYmxlLmpzIiwiY29tcG9uZW50cy9ncmFwaC9lZGdlLmpzIiwiY29tcG9uZW50cy9ncmFwaC9naXQtZ3JhcGgtYWN0aW9ucy5qcyIsImNvbXBvbmVudHMvZ3JhcGgvZ2l0LW5vZGUuanMiLCJjb21wb25lbnRzL2dyYXBoL2dpdC1yZWYuanMiLCJjb21wb25lbnRzL2dyYXBoL2dyYXBoLmpzIiwiY29tcG9uZW50cy9ncmFwaC9ob3Zlci1hY3Rpb25zLmpzIiwiY29tcG9uZW50cy9ncmFwaC9zZWxlY3RhYmxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5yZXF1aXJlKCdtaW5hJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmVsZW1lbnQgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMucHJldmlvdXNHcmFwaCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5lbGVtZW50LnN1YnNjcmliZShmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAodmFsKSBzZWxmLmFuaW1hdGUodHJ1ZSk7XG4gIH0pO1xuICB0aGlzLmFuaW1hdGUgPSBmdW5jdGlvbihmb3JjZVJlZnJlc2gpIHtcbiAgICB2YXIgY3VycmVudEdyYXBoID0gdGhpcy5nZXRHcmFwaEF0dHIoKTtcbiAgICAvLyBhbmltYXRlIG9ubHkgd2hlbiBkb20gaXMgdmFsaWQgYW5kIChhdHRyaWJ1dGUgY2hhbmdlZCBvciBmb3JjZSByZWZyZXNoIGR1ZSB0byBkb20gY2hhbmdlKVxuICAgIGlmICh0aGlzLmVsZW1lbnQoKSAmJiAoZm9yY2VSZWZyZXNoIHx8IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRHcmFwaCkgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMucHJldmlvdXNHcmFwaCkpKSB7XG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIHdpbmRvdy5taW5hKHRoaXMucHJldmlvdXNHcmFwaCB8fCBjdXJyZW50R3JhcGgsIGN1cnJlbnRHcmFwaCwgbm93LCBub3cgKyA3NTAsIHdpbmRvdy5taW5hLnRpbWUsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgc2VsZi5zZXRHcmFwaEF0dHIodmFsKTtcbiAgICAgIH0sIHdpbmRvdy5taW5hLmVsYXN0aWMpO1xuICAgICAgdGhpcy5wcmV2aW91c0dyYXBoID0gY3VycmVudEdyYXBoO1xuICAgIH1cbiAgfVxufTtcbiIsInZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG52YXIgQW5pbWF0ZWFibGUgPSByZXF1aXJlKCcuL2FuaW1hdGVhYmxlJyk7XG5cbnZhciBFZGdlVmlld01vZGVsID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGVBc2hhMSwgbm9kZUJzaGExKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgQW5pbWF0ZWFibGUuY2FsbCh0aGlzKTtcbiAgdGhpcy5ub2RlQSA9IGdyYXBoLmdldE5vZGUobm9kZUFzaGExKTtcbiAgdGhpcy5ub2RlQiA9IGdyYXBoLmdldE5vZGUobm9kZUJzaGExKTtcbiAgdGhpcy5nZXRHcmFwaEF0dHIgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi5ub2RlQi5pc0luaXRlZCAmJiBzZWxmLm5vZGVCLmN4KCkgJiYgc2VsZi5ub2RlQi5jeSgpKSB7XG4gICAgICByZXR1cm4gW3NlbGYubm9kZUEuY3goKSwgc2VsZi5ub2RlQS5jeSgpLCBzZWxmLm5vZGVBLmN4KCksIHNlbGYubm9kZUEuY3koKSxcbiAgICAgICAgICAgICAgc2VsZi5ub2RlQi5jeCgpLCBzZWxmLm5vZGVCLmN5KCksIHNlbGYubm9kZUIuY3goKSwgc2VsZi5ub2RlQi5jeSgpXTtcbiAgICB9IGVsc2UgaWYgKGdyYXBoLmdyYXBoSGVpZ2h0KCkpIHtcbiAgICAgIHJldHVybiBbc2VsZi5ub2RlQS5jeCgpLCBzZWxmLm5vZGVBLmN5KCksIHNlbGYubm9kZUEuY3goKSwgc2VsZi5ub2RlQS5jeSgpLFxuICAgICAgICAgICAgICBzZWxmLm5vZGVBLmN4KCksIGdyYXBoLmdyYXBoSGVpZ2h0KCksIHNlbGYubm9kZUEuY3goKSwgZ3JhcGguZ3JhcGhIZWlnaHQoKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbc2VsZi5ub2RlQS5jeCgpLCBzZWxmLm5vZGVBLmN5KCksIHNlbGYubm9kZUEuY3goKSwgc2VsZi5ub2RlQS5jeSgpLFxuICAgICAgICAgICAgICBzZWxmLm5vZGVBLmN4KCksIHNlbGYubm9kZUEuY3koKSwgc2VsZi5ub2RlQS5jeCgpLCBzZWxmLm5vZGVBLmN5KCldO1xuICAgIH1cbiAgfSk7XG4gIHRoaXMuZ2V0R3JhcGhBdHRyLnN1YnNjcmliZSh0aGlzLmFuaW1hdGUuYmluZCh0aGlzKSk7XG59XG5FZGdlVmlld01vZGVsLnByb3RvdHlwZS5zZXRHcmFwaEF0dHIgPSBmdW5jdGlvbih2YWwpIHtcbiAgdGhpcy5lbGVtZW50KCkuc2V0QXR0cmlidXRlKCdkJywgJ00nICsgdmFsLnNsaWNlKDAsNCkuam9pbignLCcpICsgJ0wnICsgdmFsLnNsaWNlKDQsOCkuam9pbignLCcpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRWRnZVZpZXdNb2RlbDtcbiIsIlxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBjb21wb25lbnRzID0gcmVxdWlyZSgndW5naXQtY29tcG9uZW50cycpO1xudmFyIFJlZlZpZXdNb2RlbCA9IHJlcXVpcmUoJy4vZ2l0LXJlZi5qcycpO1xudmFyIEhvdmVyQWN0aW9ucyA9IHJlcXVpcmUoJy4vaG92ZXItYWN0aW9ucycpO1xudmFyIFJlYmFzZVZpZXdNb2RlbCA9IEhvdmVyQWN0aW9ucy5SZWJhc2VWaWV3TW9kZWw7XG52YXIgTWVyZ2VWaWV3TW9kZWwgPSBIb3ZlckFjdGlvbnMuTWVyZ2VWaWV3TW9kZWw7XG52YXIgUmVzZXRWaWV3TW9kZWwgPSBIb3ZlckFjdGlvbnMuUmVzZXRWaWV3TW9kZWw7XG52YXIgUHVzaFZpZXdNb2RlbCA9IEhvdmVyQWN0aW9ucy5QdXNoVmlld01vZGVsO1xudmFyIHByb2dyYW1FdmVudHMgPSByZXF1aXJlKCd1bmdpdC1wcm9ncmFtLWV2ZW50cycpO1xuXG52YXIgR3JhcGhBY3Rpb25zID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoQWN0aW9ucztcblxuR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UgPSBmdW5jdGlvbihncmFwaCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5zZXJ2ZXIgPSBncmFwaC5zZXJ2ZXI7XG4gIHRoaXMucGVyZm9ybVByb2dyZXNzQmFyID0gY29tcG9uZW50cy5jcmVhdGUoJ3Byb2dyZXNzQmFyJywge1xuICAgIHByZWRpY3Rpb25NZW1vcnlLZXk6ICdhY3Rpb24tJyArIHRoaXMuc3R5bGUgKyAnLScgKyBncmFwaC5yZXBvUGF0aCxcbiAgICBmYWxsYmFja1ByZWRpY3RlZFRpbWVNczogMTAwMCxcbiAgICB0ZW1wb3Jhcnk6IHRydWVcbiAgfSk7XG5cbiAgdGhpcy5pc0hpZ2hsaWdodGVkID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICFncmFwaC5ob3ZlckdyYXBoQWN0aW9uKCkgfHwgZ3JhcGguaG92ZXJHcmFwaEFjdGlvbigpID09IHNlbGY7XG4gIH0pO1xuICB0aGlzLmNzc0NsYXNzZXMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICB2YXIgYyA9IHNlbGYuc3R5bGU7XG4gICAgaWYgKCFzZWxmLmlzSGlnaGxpZ2h0ZWQoKSkgYyArPSAnIGRpbW1lZCc7XG4gICAgcmV0dXJuIGM7XG4gIH0pXG59XG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5wcm90b3R5cGUuaWNvbiA9IG51bGw7XG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5wcm90b3R5cGUuZG9QZXJmb3JtID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5ncmFwaC5ob3ZlckdyYXBoQWN0aW9uKG51bGwpO1xuICBzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5zdGFydCgpO1xuICB0aGlzLnBlcmZvcm0oZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5wZXJmb3JtUHJvZ3Jlc3NCYXIuc3RvcCgpO1xuICB9KTtcbn1cbkdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLnByb3RvdHlwZS5kcmFnRW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnZpc2libGUoKSkgcmV0dXJuO1xuICB0aGlzLmdyYXBoLmhvdmVyR3JhcGhBY3Rpb24odGhpcyk7XG59XG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5wcm90b3R5cGUuZHJhZ0xlYXZlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy52aXNpYmxlKCkpIHJldHVybjtcbiAgdGhpcy5ncmFwaC5ob3ZlckdyYXBoQWN0aW9uKG51bGwpO1xufVxuR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UucHJvdG90eXBlLm1vdXNlb3ZlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdyYXBoLmhvdmVyR3JhcGhBY3Rpb24odGhpcyk7XG59XG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5wcm90b3R5cGUubW91c2VvdXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncmFwaC5ob3ZlckdyYXBoQWN0aW9uKG51bGwpO1xufVxuXG5HcmFwaEFjdGlvbnMuTW92ZSA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5ydW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgJiZcbiAgICAgIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5ub2RlKCkgIT0gc2VsZi5ub2RlO1xuICB9KTtcbn1cbmluaGVyaXRzKEdyYXBoQWN0aW9ucy5Nb3ZlLCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuTW92ZS5wcm90b3R5cGUudGV4dCA9ICdNb3ZlJztcbkdyYXBoQWN0aW9ucy5Nb3ZlLnByb3RvdHlwZS5zdHlsZSA9ICdtb3ZlJztcbkdyYXBoQWN0aW9ucy5Nb3ZlLnByb3RvdHlwZS5pY29uID0gJ2dseXBoaWNvbiBnbHlwaGljb24tbW92ZSc7XG5HcmFwaEFjdGlvbnMuTW92ZS5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5tb3ZlVG8odGhpcy5ub2RlLnNoYTEsIGNhbGxiYWNrKTtcbn1cblxuR3JhcGhBY3Rpb25zLlJlc2V0ID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCEoc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsKSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBjb250ZXh0ID0gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICAgIGlmIChjb250ZXh0Lm5vZGUoKSAhPSBzZWxmLm5vZGUpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcmVtb3RlUmVmID0gY29udGV4dC5nZXRSZW1vdGVSZWYoc2VsZi5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuICAgIHJldHVybiByZW1vdGVSZWYgJiZcbiAgICAgIHJlbW90ZVJlZi5ub2RlKCkgIT0gY29udGV4dC5ub2RlKCkgJiZcbiAgICAgIHJlbW90ZVJlZi5ub2RlKCkuZGF0ZSA8IGNvbnRleHQubm9kZSgpLmRhdGU7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLlJlc2V0LCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuUmVzZXQucHJvdG90eXBlLnRleHQgPSAnUmVzZXQnO1xuR3JhcGhBY3Rpb25zLlJlc2V0LnByb3RvdHlwZS5zdHlsZSA9ICdyZXNldCc7XG5HcmFwaEFjdGlvbnMuUmVzZXQucHJvdG90eXBlLmljb24gPSAnZ2x5cGhpY29uIGdseXBoaWNvbi10cmFzaCc7XG5HcmFwaEFjdGlvbnMuUmVzZXQucHJvdG90eXBlLmNyZWF0ZUhvdmVyR3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29udGV4dCA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgaWYgKCFjb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgdmFyIHJlbW90ZVJlZiA9IGNvbnRleHQuZ2V0UmVtb3RlUmVmKHRoaXMuZ3JhcGguY3VycmVudFJlbW90ZSgpKTtcbiAgdmFyIG5vZGVzID0gY29udGV4dC5ub2RlKCkuZ2V0UGF0aFRvQ29tbW9uQW5jZXN0b3IocmVtb3RlUmVmLm5vZGUoKSkuc2xpY2UoMCwgLTEpO1xuICByZXR1cm4gbmV3IFJlc2V0Vmlld01vZGVsKG5vZGVzKTtcbn1cbkdyYXBoQWN0aW9ucy5SZXNldC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gIHZhciBkaWFnID0gY29tcG9uZW50cy5jcmVhdGUoJ3llc25vZGlhbG9nJywgeyB0aXRsZTogJ0FyZSB5b3Ugc3VyZT8nLCBkZXRhaWxzOiAnVGhpcyBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZSB3aXRoIHVuZ2l0Lid9KTtcbiAgZGlhZy5jbG9zZWQuYWRkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChkaWFnLnJlc3VsdCgpKSB7XG4gICAgICB2YXIgcmVtb3RlUmVmID0gY29udGV4dC5nZXRSZW1vdGVSZWYoc2VsZi5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuICAgICAgc2VsZi5zZXJ2ZXIucG9zdCgnL3Jlc2V0JywgeyBwYXRoOiBzZWxmLmdyYXBoLnJlcG9QYXRoLCB0bzogcmVtb3RlUmVmLm5hbWUsIG1vZGU6ICdoYXJkJyB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgY29udGV4dC5ub2RlKHJlbW90ZVJlZi5ub2RlKCkpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9KTtcbiAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAncmVxdWVzdC1zaG93LWRpYWxvZycsIGRpYWxvZzogZGlhZyB9KTtcbn1cblxuR3JhcGhBY3Rpb25zLlJlYmFzZSA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5ydW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgJiZcbiAgICAgICghdW5naXQuY29uZmlnLnNob3dSZWJhc2VBbmRNZXJnZU9ubHlPblJlZnMgfHwgc2VsZi5ub2RlLnJlZnMoKS5sZW5ndGggPiAwKSAmJlxuICAgICAgc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLmN1cnJlbnQoKSAmJlxuICAgICAgc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLm5vZGUoKSAhPSBzZWxmLm5vZGU7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLlJlYmFzZSwgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLlJlYmFzZS5wcm90b3R5cGUudGV4dCA9ICdSZWJhc2UnO1xuR3JhcGhBY3Rpb25zLlJlYmFzZS5wcm90b3R5cGUuc3R5bGUgPSAncmViYXNlJztcbkdyYXBoQWN0aW9ucy5SZWJhc2UucHJvdG90eXBlLmljb24gPSAnb2N0aWNvbiBvY3RpY29uLXJlcG8tZm9ya2VkIGZsaXAnO1xuR3JhcGhBY3Rpb25zLlJlYmFzZS5wcm90b3R5cGUuY3JlYXRlSG92ZXJHcmFwaGljID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvbnRvID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICBpZiAoIW9udG8pIHJldHVybjtcbiAgaWYgKG9udG8gaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwpIG9udG8gPSBvbnRvLm5vZGUoKTtcbiAgdmFyIHBhdGggPSBvbnRvLmdldFBhdGhUb0NvbW1vbkFuY2VzdG9yKHRoaXMubm9kZSk7XG4gIHJldHVybiBuZXcgUmViYXNlVmlld01vZGVsKHRoaXMubm9kZSwgcGF0aCk7XG59XG5HcmFwaEFjdGlvbnMuUmViYXNlLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5zZXJ2ZXIucG9zdCgnL3JlYmFzZScsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCwgb250bzogdGhpcy5ub2RlLnNoYTEgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICBpZiAoZXJyICYmIGVyci5lcnJvckNvZGUgPT0gJ21lcmdlLWZhaWxlZCcpIHJldHVybiB0cnVlO1xuICB9KTtcbn1cblxuR3JhcGhBY3Rpb25zLk1lcmdlID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFzZWxmLmdyYXBoLmNoZWNrZWRPdXRSZWYoKSB8fCAhc2VsZi5ncmFwaC5jaGVja2VkT3V0UmVmKCkubm9kZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJlxuICAgICAgIXNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5jdXJyZW50KCkgJiZcbiAgICAgIHNlbGYuZ3JhcGguY2hlY2tlZE91dFJlZigpLm5vZGUoKSA9PSBzZWxmLm5vZGU7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLk1lcmdlLCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuTWVyZ2UucHJvdG90eXBlLnRleHQgPSAnTWVyZ2UnO1xuR3JhcGhBY3Rpb25zLk1lcmdlLnByb3RvdHlwZS5zdHlsZSA9ICdtZXJnZSc7XG5HcmFwaEFjdGlvbnMuTWVyZ2UucHJvdG90eXBlLmljb24gPSAnb2N0aWNvbiBvY3RpY29uLWdpdC1tZXJnZSc7XG5HcmFwaEFjdGlvbnMuTWVyZ2UucHJvdG90eXBlLmNyZWF0ZUhvdmVyR3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwpIG5vZGUgPSBub2RlLm5vZGUoKTtcbiAgcmV0dXJuIG5ldyBNZXJnZVZpZXdNb2RlbCh0aGlzLmdyYXBoLCB0aGlzLm5vZGUsIG5vZGUpO1xufVxuR3JhcGhBY3Rpb25zLk1lcmdlLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5zZXJ2ZXIucG9zdCgnL21lcmdlJywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoLCB3aXRoOiB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubG9jYWxSZWZOYW1lIH0sIGZ1bmN0aW9uKGVycikge1xuICAgIGNhbGxiYWNrKCk7XG4gICAgaWYgKGVyciAmJiBlcnIuZXJyb3JDb2RlID09ICdtZXJnZS1mYWlsZWQnKSByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5cbkdyYXBoQWN0aW9ucy5QdXNoID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJlxuICAgICAgc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLm5vZGUoKSA9PSBzZWxmLm5vZGUgJiZcbiAgICAgIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5jYW5CZVB1c2hlZChzZWxmLmdyYXBoLmN1cnJlbnRSZW1vdGUoKSk7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLlB1c2gsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5QdXNoLnByb3RvdHlwZS50ZXh0ID0gJ1B1c2gnO1xuR3JhcGhBY3Rpb25zLlB1c2gucHJvdG90eXBlLnN0eWxlID0gJ3B1c2gnO1xuR3JhcGhBY3Rpb25zLlB1c2gucHJvdG90eXBlLmljb24gPSAnb2N0aWNvbiBvY3RpY29uLWNsb3VkLXVwbG9hZCc7XG5HcmFwaEFjdGlvbnMuUHVzaC5wcm90b3R5cGUuY3JlYXRlSG92ZXJHcmFwaGljID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICBpZiAoIWNvbnRleHQpIHJldHVybiBudWxsO1xuICB2YXIgcmVtb3RlUmVmID0gY29udGV4dC5nZXRSZW1vdGVSZWYodGhpcy5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuICBpZiAoIXJlbW90ZVJlZikgcmV0dXJuIG51bGw7XG4gIHJldHVybiBuZXcgUHVzaFZpZXdNb2RlbChyZW1vdGVSZWYubm9kZSgpLCBjb250ZXh0Lm5vZGUoKSk7XG59XG5HcmFwaEFjdGlvbnMuUHVzaC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJlZiA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgdmFyIHJlbW90ZVJlZiA9IHJlZi5nZXRSZW1vdGVSZWYodGhpcy5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuXG4gIGlmIChyZW1vdGVSZWYpIHtcbiAgICByZW1vdGVSZWYubW92ZVRvKHJlZi5ub2RlKCkuc2hhMSwgY2FsbGJhY2spO1xuICB9IGVsc2UgcmVmLmNyZWF0ZVJlbW90ZVJlZihmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoIWVyciAmJiBzZWxmLmdyYXBoLkhFQUQoKS5uYW1lID09IHJlZi5uYW1lKSB7XG4gICAgICBzZWxmLmdyYWguSEVBRHJlZigpLm5vZGUocmVmLm5vZGUoKSk7XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xufVxuXG5HcmFwaEFjdGlvbnMuQ2hlY2tvdXQgPSBmdW5jdGlvbihncmFwaCwgbm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi5wZXJmb3JtUHJvZ3Jlc3NCYXIucnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsKVxuICAgICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5ub2RlKCkgPT0gc2VsZi5ub2RlICYmXG4gICAgICAgICFzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkuY3VycmVudCgpO1xuICAgIHJldHVybiB1bmdpdC5jb25maWcuYWxsb3dDaGVja291dE5vZGVzICYmXG4gICAgICBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgPT0gc2VsZi5ub2RlO1xuICB9KTtcbn1cbmluaGVyaXRzKEdyYXBoQWN0aW9ucy5DaGVja291dCwgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLkNoZWNrb3V0LnByb3RvdHlwZS50ZXh0ID0gJ0NoZWNrb3V0JztcbkdyYXBoQWN0aW9ucy5DaGVja291dC5wcm90b3R5cGUuc3R5bGUgPSAnY2hlY2tvdXQnO1xuR3JhcGhBY3Rpb25zLkNoZWNrb3V0LnByb3RvdHlwZS5pY29uID0gJ29jdGljb24gb2N0aWNvbi1kZXNrdG9wLWRvd25sb2FkJztcbkdyYXBoQWN0aW9ucy5DaGVja291dC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gIHZhciByZWZOYW1lID0gY29udGV4dCBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCA/IGNvbnRleHQucmVmTmFtZSA6IGNvbnRleHQuc2hhMTtcbiAgdGhpcy5zZXJ2ZXIucG9zdCgnL2NoZWNrb3V0JywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoLCBuYW1lOiByZWZOYW1lIH0sIGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmVycm9yQ29kZSAhPSAnbWVyZ2UtZmFpbGVkJykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJiBjb250ZXh0LmlzUmVtb3RlQnJhbmNoKSB7XG4gICAgICBzZWxmLnNlcnZlci5wb3N0KCcvcmVzZXQnLCB7IHBhdGg6IHNlbGYuZ3JhcGgucmVwb1BhdGgsIHRvOiBjb250ZXh0Lm5hbWUsIG1vZGU6ICdoYXJkJyB9LCBmdW5jdGlvbihlcnIsIHJlcykge1xuICAgICAgICBzZWxmLmdyYXBoLkhFQURyZWYoKS5ub2RlKGNvbnRleHQgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgPyBjb250ZXh0Lm5vZGUoKSA6IGNvbnRleHQpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm4gZXJyICYmIGVyci5lcnJvckNvZGUgIT0gJ21lcmdlLWZhaWxlZCcgPyB1bmRlZmluZWQgOiB0cnVlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuZ3JhcGguSEVBRHJlZigpLm5vZGUoY29udGV4dCBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCA/IGNvbnRleHQubm9kZSgpIDogY29udGV4dCk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5cbkdyYXBoQWN0aW9ucy5EZWxldGUgPSBmdW5jdGlvbihncmFwaCwgbm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi5wZXJmb3JtUHJvZ3Jlc3NCYXIucnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsICYmXG4gICAgICBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubm9kZSgpID09IHNlbGYubm9kZSAmJlxuICAgICAgIXNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5jdXJyZW50KCk7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLkRlbGV0ZSwgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLkRlbGV0ZS5wcm90b3R5cGUudGV4dCA9ICdEZWxldGUnO1xuR3JhcGhBY3Rpb25zLkRlbGV0ZS5wcm90b3R5cGUuc3R5bGUgPSAnZGVsZXRlJztcbkdyYXBoQWN0aW9ucy5EZWxldGUucHJvdG90eXBlLmljb24gPSAnZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmUnO1xuR3JhcGhBY3Rpb25zLkRlbGV0ZS5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICB2YXIgZGlhZyA9IGNvbXBvbmVudHMuY3JlYXRlKCd5ZXNub2RpYWxvZycsIHsgdGl0bGU6ICdBcmUgeW91IHN1cmU/JywgZGV0YWlsczogJ1RoaXMgb3BlcmF0aW9uIGNhbm5vdCBiZSB1bmRvbmUgd2l0aCB1bmdpdC4nfSk7XG4gIGRpYWcuY2xvc2VkLmFkZChmdW5jdGlvbigpIHtcbiAgICBpZiAoZGlhZy5yZXN1bHQoKSkge1xuICAgICAgY29udGV4dC5yZW1vdmUoY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfSk7XG4gIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ3JlcXVlc3Qtc2hvdy1kaWFsb2cnLCBkaWFsb2c6IGRpYWcgfSk7XG59XG5cbkdyYXBoQWN0aW9ucy5DaGVycnlQaWNrID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSA9PSBzZWxmLm5vZGVcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuQ2hlcnJ5UGljaywgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLkNoZXJyeVBpY2sucHJvdG90eXBlLnRleHQgPSAnQ2hlcnJ5IHBpY2snO1xuR3JhcGhBY3Rpb25zLkNoZXJyeVBpY2sucHJvdG90eXBlLnN0eWxlID0gJ2NoZXJyeS1waWNrJztcbkdyYXBoQWN0aW9ucy5DaGVycnlQaWNrLnByb3RvdHlwZS5pY29uID0gJ29jdGljb24gb2N0aWNvbi1jaXJjdWl0LWJvYXJkJztcbkdyYXBoQWN0aW9ucy5DaGVycnlQaWNrLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlcnZlci5wb3N0KCcvY2hlcnJ5cGljaycsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCwgbmFtZTogdGhpcy5ub2RlLnNoYTEgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICBpZiAoZXJyICYmIGVyci5lcnJvckNvZGUgPT0gJ21lcmdlLWZhaWxlZCcpIHJldHVybiB0cnVlO1xuICB9KTtcbn1cblxuR3JhcGhBY3Rpb25zLlVuY29tbWl0ID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSA9PSBzZWxmLm5vZGUgJiZcbiAgICAgIHNlbGYuZ3JhcGguSEVBRCgpID09IHNlbGYubm9kZTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuVW5jb21taXQsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5VbmNvbW1pdC5wcm90b3R5cGUudGV4dCA9ICdVbmNvbW1pdCc7XG5HcmFwaEFjdGlvbnMuVW5jb21taXQucHJvdG90eXBlLnN0eWxlID0gJ3VuY29tbWl0JztcbkdyYXBoQWN0aW9ucy5VbmNvbW1pdC5wcm90b3R5cGUuaWNvbiA9ICdvY3RpY29uIG9jdGljb24temFwJztcbkdyYXBoQWN0aW9ucy5VbmNvbW1pdC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9yZXNldCcsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCwgdG86ICdIRUFEXicsIG1vZGU6ICdtaXhlZCcgfSlcbiAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0YXJnZXROb2RlID0gc2VsZi5ub2RlLmJlbG93Tm9kZTtcbiAgICAgIHdoaWxlICh0YXJnZXROb2RlICYmICF0YXJnZXROb2RlLmFuY2VzdG9yT2ZIRUFEKCkpIHtcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IHRhcmdldE5vZGUuYmVsb3dOb2RlO1xuICAgICAgfVxuICAgICAgc2VsZi5ncmFwaC5IRUFEcmVmKCkubm9kZSh0YXJnZXROb2RlID8gdGFyZ2V0Tm9kZSA6IG51bGwpO1xuICAgICAgc2VsZi5ncmFwaC5jaGVja2VkT3V0UmVmKCkubm9kZSh0YXJnZXROb2RlID8gdGFyZ2V0Tm9kZSA6IG51bGwpO1xuICAgIH0pLmZpbmFsbHkoY2FsbGJhY2spO1xufVxuXG5HcmFwaEFjdGlvbnMuUmV2ZXJ0ID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSA9PSBzZWxmLm5vZGU7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLlJldmVydCwgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLlJldmVydC5wcm90b3R5cGUudGV4dCA9ICdSZXZlcnQnO1xuR3JhcGhBY3Rpb25zLlJldmVydC5wcm90b3R5cGUuc3R5bGUgPSAncmV2ZXJ0JztcbkdyYXBoQWN0aW9ucy5SZXZlcnQucHJvdG90eXBlLmljb24gPSAnb2N0aWNvbiBvY3RpY29uLWhpc3RvcnknO1xuR3JhcGhBY3Rpb25zLlJldmVydC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9yZXZlcnQnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgsIGNvbW1pdDogdGhpcy5ub2RlLnNoYTEgfSlcbiAgICAuZmluYWxseShjYWxsYmFjayk7XG59XG4iLCJ2YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xudmFyIGNvbXBvbmVudHMgPSByZXF1aXJlKCd1bmdpdC1jb21wb25lbnRzJyk7XG52YXIgU2VsZWN0YWJsZSA9IHJlcXVpcmUoJy4vc2VsZWN0YWJsZScpO1xudmFyIEFuaW1hdGVhYmxlID0gcmVxdWlyZSgnLi9hbmltYXRlYWJsZScpO1xudmFyIHByb2dyYW1FdmVudHMgPSByZXF1aXJlKCd1bmdpdC1wcm9ncmFtLWV2ZW50cycpO1xudmFyIEdyYXBoQWN0aW9ucyA9IHJlcXVpcmUoJy4vZ2l0LWdyYXBoLWFjdGlvbnMnKTtcblxudmFyIEdpdE5vZGVWaWV3TW9kZWwgPSBmdW5jdGlvbihncmFwaCwgc2hhMSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIFNlbGVjdGFibGUuY2FsbCh0aGlzLCBncmFwaCk7XG4gIEFuaW1hdGVhYmxlLmNhbGwodGhpcyk7XG4gIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5zaGExID0gc2hhMTtcbiAgdGhpcy5pc0luaXRlZCA9IGZhbHNlO1xuICB0aGlzLnRpdGxlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudHMgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgdGhpcy5jb21taXRUaW1lID0gdW5kZWZpbmVkOyAvLyBjb21taXQgdGltZSBpbiBzdHJpbmdcbiAgdGhpcy5kYXRlID0gdW5kZWZpbmVkOyAgICAgICAvLyBjb21taXQgdGltZSBpbiBudW1lcmljIGZvcm1hdCBmb3Igc29ydFxuICB0aGlzLmNvbG9yID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmlkZW9sb2dpY2FsQnJhbmNoID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLnJlbW90ZVRhZ3MgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgdGhpcy5icmFuY2hlc0FuZExvY2FsVGFncyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuXG4gIHRoaXMucmVmcyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHZhciBycyA9IHNlbGYuYnJhbmNoZXNBbmRMb2NhbFRhZ3MoKS5jb25jYXQoc2VsZi5yZW1vdGVUYWdzKCkpO1xuICAgIHJzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYgKGEuaXNMb2NhbCAmJiAhYi5pc0xvY2FsKSByZXR1cm4gLTE7XG4gICAgICBpZiAoIWEuaXNMb2NhbCAmJiBiLmlzTG9jYWwpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIGEucmVmTmFtZSA8IGIucmVmTmFtZSA/IC0xIDogMTtcbiAgICB9KTtcbiAgICByZXR1cm4gcnM7XG4gIH0pO1xuICB0aGlzLmFuY2VzdG9yT2ZIRUFEID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMubm9kZUlzTW91c2Vob3ZlciA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmNvbW1pdENvbnRhaW5lclZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5hbmNlc3Rvck9mSEVBRCgpIHx8IHNlbGYubm9kZUlzTW91c2Vob3ZlcigpIHx8IHNlbGYuc2VsZWN0ZWQoKTtcbiAgfSk7XG4gIHRoaXMuaGlnaGxpZ2h0ZWQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5ub2RlSXNNb3VzZWhvdmVyKCkgfHwgc2VsZi5zZWxlY3RlZCgpO1xuICB9KTtcbiAgdGhpcy5zZWxlY3RlZC5zdWJzY3JpYmUoZnVuY3Rpb24oKSB7XG4gICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAnZ3JhcGgtcmVuZGVyJyB9KTtcbiAgfSk7XG4gIHRoaXMuY29tbWl0Q29tcG9uZW50ID0gY29tcG9uZW50cy5jcmVhdGUoJ2NvbW1pdCcsIHtcbiAgICBzaGExOiB0aGlzLnNoYTEsXG4gICAgcmVwb1BhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgsXG4gICAgc2VydmVyOiB0aGlzLmdyYXBoLnNlcnZlcixcbiAgICBzZWxlY3RlZDogdGhpcy5zZWxlY3RlZCxcbiAgICBoaWdobGlnaHRlZDogdGhpcy5oaWdobGlnaHRlZCxcbiAgICBub2RlSXNNb3VzZWhvdmVyOiB0aGlzLm5vZGVJc01vdXNlaG92ZXJcbiAgfSk7XG4gIC8vIFRoZXNlIGFyZSBzcGxpdCB1cCBsaWtlIHRoaXMgYmVjYXVzZSBicmFuY2hlcyBhbmQgbG9jYWwgdGFncyBjYW4gYmUgZm91bmQgaW4gdGhlIGdpdCBsb2csXG4gIC8vIHdoZXJlYXMgcmVtb3RlIHRhZ3MgbmVlZHMgdG8gYmUgZmV0Y2hlZCB3aXRoIGFub3RoZXIgY29tbWFuZCAod2hpY2ggaXMgbXVjaCBzbG93ZXIpXG4gIHRoaXMuYnJhbmNoZXMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5yZWZzKCkuZmlsdGVyKGZ1bmN0aW9uKHIpIHsgcmV0dXJuIHIuaXNCcmFuY2g7IH0pO1xuICB9KTtcbiAgdGhpcy50YWdzID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYucmVmcygpLmZpbHRlcihmdW5jdGlvbihyKSB7IHJldHVybiByLmlzVGFnOyB9KTtcbiAgfSk7XG4gIHRoaXMuc2hvd05ld1JlZkFjdGlvbiA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgfSk7XG4gIHRoaXMubmV3QnJhbmNoTmFtZSA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5uZXdCcmFuY2hOYW1lSGFzRm9jdXMgPSBrby5vYnNlcnZhYmxlKHRydWUpO1xuICB0aGlzLm5ld0JyYW5jaE5hbWVIYXNGb2N1cy5zdWJzY3JpYmUoZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICBpZiAoIW5ld1ZhbHVlKSB7XG4gICAgICAvLyBTbWFsbCB0aW1lb3V0IGJlY2F1c2UgaW4gZmYgdGhlIGZvcm0gaXMgaGlkZGVuIGJlZm9yZSB0aGUgc3VibWl0IGNsaWNrIGV2ZW50IGlzIHJlZ2lzdGVyZWQgb3RoZXJ3aXNlXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmJyYW5jaGluZ0Zvcm1WaXNpYmxlKGZhbHNlKTtcbiAgICAgIH0sIDIwMCk7XG4gICAgfVxuICB9KTtcbiAgdGhpcy5icmFuY2hpbmdGb3JtVmlzaWJsZSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmNhbkNyZWF0ZVJlZiA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLm5ld0JyYW5jaE5hbWUoKSAmJiBzZWxmLm5ld0JyYW5jaE5hbWUoKS50cmltKCkgJiYgc2VsZi5uZXdCcmFuY2hOYW1lKCkuaW5kZXhPZignICcpID09IC0xO1xuICB9KTtcbiAgdGhpcy5icmFuY2hPcmRlciA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5hYm92ZU5vZGUgPSB1bmRlZmluZWQ7XG4gIHRoaXMuYmVsb3dOb2RlID0gdW5kZWZpbmVkO1xuXG4gIHRoaXMuciA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5jeCA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5jeSA9IGtvLm9ic2VydmFibGUoKTtcblxuICB0aGlzLmRyb3BhcmVhR3JhcGhBY3Rpb25zID0gW1xuICAgIG5ldyBHcmFwaEFjdGlvbnMuTW92ZSh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLlJlYmFzZSh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLk1lcmdlKHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuUHVzaCh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLlJlc2V0KHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuQ2hlY2tvdXQodGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5EZWxldGUodGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5DaGVycnlQaWNrKHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuVW5jb21taXQodGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5SZXZlcnQodGhpcy5ncmFwaCwgdGhpcylcbiAgXTtcbn1cbm1vZHVsZS5leHBvcnRzID0gR2l0Tm9kZVZpZXdNb2RlbDtcblxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0R3JhcGhBdHRyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdGhpcy5jeCgpLCB0aGlzLmN5KCldO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuc2V0R3JhcGhBdHRyID0gZnVuY3Rpb24odmFsKSB7XG4gIHRoaXMuZWxlbWVudCgpLnNldEF0dHJpYnV0ZSgneCcsIHZhbFswXSAtIDMwKTtcbiAgdGhpcy5lbGVtZW50KCkuc2V0QXR0cmlidXRlKCd5JywgdmFsWzFdIC0gMzApO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5pc0luaXRlZCkgcmV0dXJuO1xuICBpZiAodGhpcy5hbmNlc3Rvck9mSEVBRCgpKSB7XG4gICAgdGhpcy5yKDMwKTtcbiAgICB0aGlzLmN4KDYxMCk7XG5cbiAgICBpZiAoIXRoaXMuYWJvdmVOb2RlKSB7XG4gICAgICB0aGlzLmN5KDEyMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFib3ZlTm9kZS5hbmNlc3Rvck9mSEVBRCgpKSB7XG4gICAgICB0aGlzLmN5KHRoaXMuYWJvdmVOb2RlLmN5KCkgKyAxMjApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN5KHRoaXMuYWJvdmVOb2RlLmN5KCkgKyA2MCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMucigxNSk7XG4gICAgdGhpcy5jeCg2MTAgKyAoOTAgKiB0aGlzLmJyYW5jaE9yZGVyKCkpKTtcbiAgICB0aGlzLmN5KHRoaXMuYWJvdmVOb2RlID8gdGhpcy5hYm92ZU5vZGUuY3koKSArIDYwIDogMTIwKTtcbiAgfVxuXG4gIGlmICh0aGlzLmFib3ZlTm9kZSAmJiB0aGlzLmFib3ZlTm9kZS5zZWxlY3RlZCgpKSB7XG4gICAgdGhpcy5jeSh0aGlzLmFib3ZlTm9kZS5jeSgpICsgdGhpcy5hYm92ZU5vZGUuY29tbWl0Q29tcG9uZW50LmVsZW1lbnQoKS5vZmZzZXRIZWlnaHQgKyAzMCk7XG4gIH1cblxuICB0aGlzLmNvbW1pdENvbXBvbmVudC5zZWxlY3RlZERpZmZMZWZ0UG9zaXRpb24oLSh0aGlzLmN4KCkgLSA2MDApKTtcbiAgdGhpcy5jb2xvcih0aGlzLmlkZW9sb2dpY2FsQnJhbmNoKCkgPyB0aGlzLmlkZW9sb2dpY2FsQnJhbmNoKCkuY29sb3IgOiAnIzY2NicpO1xuICB0aGlzLmFuaW1hdGUoKTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbihsb2dFbnRyeSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMudGl0bGUgPSBsb2dFbnRyeS5tZXNzYWdlLnNwbGl0KCdcXG4nKVswXTtcbiAgdGhpcy5wYXJlbnRzKGxvZ0VudHJ5LnBhcmVudHMgfHwgW10pO1xuICB0aGlzLmNvbW1pdFRpbWUgPSBsb2dFbnRyeS5jb21taXREYXRlO1xuICB0aGlzLmRhdGUgPSBEYXRlLnBhcnNlKHRoaXMuY29tbWl0VGltZSk7XG4gIHRoaXMuY29tbWl0Q29tcG9uZW50LnNldERhdGEobG9nRW50cnkpO1xuXG4gIGlmIChsb2dFbnRyeS5yZWZzKSB7XG4gICAgdmFyIHJlZlZNcyA9IGxvZ0VudHJ5LnJlZnMubWFwKGZ1bmN0aW9uKHJlZikge1xuICAgICAgdmFyIHJlZlZpZXdNb2RlbCA9IHNlbGYuZ3JhcGguZ2V0UmVmKHJlZik7XG4gICAgICByZWZWaWV3TW9kZWwubm9kZShzZWxmKTtcbiAgICAgIHJldHVybiByZWZWaWV3TW9kZWw7XG4gICAgfSk7XG4gICAgdGhpcy5icmFuY2hlc0FuZExvY2FsVGFncyhyZWZWTXMpO1xuICB9XG5cbiAgdGhpcy5pc0luaXRlZCA9IHRydWU7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5zaG93QnJhbmNoaW5nRm9ybSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJyYW5jaGluZ0Zvcm1WaXNpYmxlKHRydWUpO1xuICB0aGlzLm5ld0JyYW5jaE5hbWVIYXNGb2N1cyh0cnVlKTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLmNyZWF0ZUJyYW5jaCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY2FuQ3JlYXRlUmVmKCkpIHJldHVybjtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmdyYXBoLnNlcnZlci5wb3N0UHJvbWlzZSgnL2JyYW5jaGVzJywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoLCBuYW1lOiB0aGlzLm5ld0JyYW5jaE5hbWUoKSwgc3RhcnRQb2ludDogdGhpcy5zaGExIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV3UmVmID0gc2VsZi5ncmFwaC5nZXRSZWYoJ3JlZnMvaGVhZHMvJyArIHNlbGYubmV3QnJhbmNoTmFtZSgpKTtcbiAgICAgIG5ld1JlZi5ub2RlKHNlbGYpO1xuICAgICAgc2VsZi5icmFuY2hlc0FuZExvY2FsVGFncy5wdXNoKG5ld1JlZik7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuYnJhbmNoaW5nRm9ybVZpc2libGUoZmFsc2UpO1xuICAgICAgc2VsZi5uZXdCcmFuY2hOYW1lKCcnKTtcbiAgICAgIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ2JyYW5jaC11cGRhdGVkJyB9KTtcbiAgICB9KTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLmNyZWF0ZVRhZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY2FuQ3JlYXRlUmVmKCkpIHJldHVybjtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmdyYXBoLnNlcnZlci5wb3N0UHJvbWlzZSgnL3RhZ3MnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgsIG5hbWU6IHRoaXMubmV3QnJhbmNoTmFtZSgpLCBzdGFydFBvaW50OiB0aGlzLnNoYTEgfSlcbiAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuZXdSZWYgPSBzZWxmLmdyYXBoLmdldFJlZigndGFnOiByZWZzL3RhZ3MvJyArIHNlbGYubmV3QnJhbmNoTmFtZSgpKTtcbiAgICAgIG5ld1JlZi5ub2RlKHNlbGYpO1xuICAgICAgc2VsZi5icmFuY2hlc0FuZExvY2FsVGFncy5wdXNoKG5ld1JlZik7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuYnJhbmNoaW5nRm9ybVZpc2libGUoZmFsc2UpO1xuICAgICAgc2VsZi5uZXdCcmFuY2hOYW1lKCcnKTtcbiAgICB9KTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnRvZ2dsZVNlbGVjdGVkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGJlZm9yZVRoaXNDUiA9IHRoaXMuY29tbWl0Q29tcG9uZW50LmVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGJlZm9yZUJlbG93Q1IgPSBudWxsO1xuICBpZiAodGhpcy5iZWxvd05vZGUpIHtcbiAgICBiZWZvcmVCZWxvd0NSID0gdGhpcy5iZWxvd05vZGUuY29tbWl0Q29tcG9uZW50LmVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuXG4gIHZhciBwcmV2U2VsZWN0ZWQgID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICBpZiAoIShwcmV2U2VsZWN0ZWQgaW5zdGFuY2VvZiBHaXROb2RlVmlld01vZGVsKSkgcHJldlNlbGVjdGVkID0gbnVsbDtcbiAgdmFyIHByZXZTZWxlY3RlZENSID0gcHJldlNlbGVjdGVkID8gcHJldlNlbGVjdGVkLmNvbW1pdENvbXBvbmVudC5lbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBudWxsO1xuICB0aGlzLnNlbGVjdGVkKCF0aGlzLnNlbGVjdGVkKCkpO1xuXG4gIC8vIElmIHdlIGFyZSBkZXNlbGVjdGluZ1xuICBpZiAoIXRoaXMuc2VsZWN0ZWQoKSkge1xuICAgIGlmIChiZWZvcmVUaGlzQ1IudG9wIDwgMCAmJiBiZWZvcmVCZWxvd0NSKSB7XG4gICAgICB2YXIgYWZ0ZXJCZWxvd0NSID0gdGhpcy5iZWxvd05vZGUuY29tbWl0Q29tcG9uZW50LmVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgc2hvd2luZywgdHJ5IHRvIGtlZXAgaXQgaW4gdGhlIHNjcmVlbiAobm8ganVtcGluZylcbiAgICAgIGlmIChiZWZvcmVCZWxvd0NSLnRvcCA8IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgYWZ0ZXJCZWxvd0NSLnRvcCAtIGJlZm9yZUJlbG93Q1IudG9wKTtcbiAgICAgIC8vIE90aGVyd2lzZSBqdXN0IHRyeSB0byBicmluZyB0aGVtIHRvIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIGFmdGVyQmVsb3dDUi50b3AgLSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICB9XG4gIC8vIElmIHdlIGFyZSBzZWxlY3RpbmdcbiAgfSBlbHNlIHtcbiAgICB2YXIgYWZ0ZXJUaGlzQ1IgPSB0aGlzLmNvbW1pdENvbXBvbmVudC5lbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKChwcmV2U2VsZWN0ZWRDUiAmJiAocHJldlNlbGVjdGVkQ1IudG9wIDwgMCB8fCBwcmV2U2VsZWN0ZWRDUi50b3AgPiB3aW5kb3cuaW5uZXJIZWlnaHQpKSAmJlxuICAgICAgYWZ0ZXJUaGlzQ1IudG9wICE9IGJlZm9yZVRoaXNDUi50b3ApIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxCeSgwLCAtKGJlZm9yZVRoaXNDUi50b3AgLSBhZnRlclRoaXNDUi50b3ApKTtcbiAgICAgIGNvbnNvbGUubG9nKCdGaXgnKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5yZW1vdmVSZWYgPSBmdW5jdGlvbihyZWYpIHtcbiAgaWYgKHJlZi5pc1JlbW90ZVRhZykge1xuICAgIHRoaXMucmVtb3RlVGFncy5yZW1vdmUocmVmKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmJyYW5jaGVzQW5kTG9jYWxUYWdzLnJlbW92ZShyZWYpO1xuICB9XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5wdXNoUmVmID0gZnVuY3Rpb24ocmVmKSB7XG4gIGlmIChyZWYuaXNSZW1vdGVUYWcpIHtcbiAgICB0aGlzLnJlbW90ZVRhZ3MucHVzaChyZWYpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYnJhbmNoZXNBbmRMb2NhbFRhZ3MucHVzaChyZWYpO1xuICB9XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5nZXRQYXRoVG9Db21tb25BbmNlc3RvciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgdmFyIHRoaXNOb2RlID0gdGhpcztcbiAgd2hpbGUgKHRoaXNOb2RlICYmICFub2RlLmlzQW5jZXN0b3IodGhpc05vZGUpKSB7XG4gICAgcGF0aC5wdXNoKHRoaXNOb2RlKTtcbiAgICB0aGlzTm9kZSA9IHRoaXMuZ3JhcGgubm9kZXNCeUlkW3RoaXNOb2RlLnBhcmVudHMoKVswXV07XG4gIH1cbiAgaWYgKHRoaXNOb2RlKSBwYXRoLnB1c2godGhpc05vZGUpO1xuICByZXR1cm4gcGF0aDtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLmlzQW5jZXN0b3IgPSBmdW5jdGlvbihub2RlKSB7XG4gIGlmIChub2RlID09IHRoaXMpIHJldHVybiB0cnVlO1xuICBmb3IgKHZhciB2IGluIHRoaXMucGFyZW50cygpKSB7XG4gICAgdmFyIG4gPSB0aGlzLmdyYXBoLm5vZGVzQnlJZFt0aGlzLnBhcmVudHMoKVt2XV07XG4gICAgaWYgKG4gJiYgbi5pc0FuY2VzdG9yKG5vZGUpKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5nZXRSaWdodFRvTGVmdFN0cmlrZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ00gJyArICh0aGlzLmN4KCkgLSAzMCkgKyAnICcgKyAodGhpcy5jeSgpIC0gMzApICsgJyBMICcgKyAodGhpcy5jeCgpICsgMzApICsgJyAnICsgKHRoaXMuY3koKSArIDMwKTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLmdldExlZnRUb1JpZ2h0U3RyaWtlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnTSAnICsgKHRoaXMuY3goKSArIDMwKSArICcgJyArICh0aGlzLmN5KCkgLSAzMCkgKyAnIEwgJyArICh0aGlzLmN4KCkgLSAzMCkgKyAnICcgKyAodGhpcy5jeSgpICsgMzApO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUubm9kZU1vdXNlb3ZlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm5vZGVJc01vdXNlaG92ZXIodHJ1ZSk7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5ub2RlTW91c2VvdXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ub2RlSXNNb3VzZWhvdmVyKGZhbHNlKTtcbn1cbiIsInZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG52YXIgbWQ1ID0gcmVxdWlyZSgnYmx1ZWltcC1tZDUnKTtcbnZhciBTZWxlY3RhYmxlID0gcmVxdWlyZSgnLi9zZWxlY3RhYmxlJyk7XG52YXIgcHJvZ3JhbUV2ZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LXByb2dyYW0tZXZlbnRzJyk7XG52YXIgY29tcG9uZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LWNvbXBvbmVudHMnKTtcblxudmFyIFJlZlZpZXdNb2RlbCA9IGZ1bmN0aW9uKGZ1bGxSZWZOYW1lLCBncmFwaCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIFNlbGVjdGFibGUuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5uYW1lID0gZnVsbFJlZk5hbWU7XG4gIHRoaXMubm9kZSA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5sb2NhbFJlZk5hbWUgPSB0aGlzLm5hbWU7IC8vIG9yaWdpbi9tYXN0ZXIgb3IgbWFzdGVyXG4gIHRoaXMucmVmTmFtZSA9IHRoaXMubmFtZTsgLy8gbWFzdGVyXG4gIHRoaXMuaXNSZW1vdGVUYWcgPSB0aGlzLm5hbWUuaW5kZXhPZigncmVtb3RlLXRhZzogJykgPT0gMDtcbiAgdGhpcy5pc0xvY2FsVGFnID0gdGhpcy5uYW1lLmluZGV4T2YoJ3RhZzogJykgPT0gMDtcbiAgdGhpcy5pc1RhZyA9IHRoaXMuaXNMb2NhbFRhZyB8fCB0aGlzLmlzUmVtb3RlVGFnO1xuICB2YXIgaXNSZW1vdGVCcmFuY2hPckhFQUQgPSB0aGlzLm5hbWUuaW5kZXhPZigncmVmcy9yZW1vdGVzLycpID09IDA7XG4gIHRoaXMuaXNMb2NhbEhFQUQgPSB0aGlzLm5hbWUgPT0gJ0hFQUQnO1xuICB0aGlzLmlzUmVtb3RlSEVBRCA9IHRoaXMubmFtZS5pbmRleE9mKCcvSEVBRCcpICE9IC0xO1xuICB0aGlzLmlzTG9jYWxCcmFuY2ggPSB0aGlzLm5hbWUuaW5kZXhPZigncmVmcy9oZWFkcy8nKSA9PSAwO1xuICB0aGlzLmlzUmVtb3RlQnJhbmNoID0gaXNSZW1vdGVCcmFuY2hPckhFQUQgJiYgIXRoaXMuaXNSZW1vdGVIRUFEO1xuICB0aGlzLmlzU3Rhc2ggPSB0aGlzLm5hbWUuaW5kZXhPZigncmVmcy9zdGFzaCcpID09IDA7XG4gIHRoaXMuaXNIRUFEID0gdGhpcy5pc0xvY2FsSEVBRCB8fCB0aGlzLmlzUmVtb3RlSEVBRDtcbiAgdGhpcy5pc0JyYW5jaCA9IHRoaXMuaXNMb2NhbEJyYW5jaCB8fCB0aGlzLmlzUmVtb3RlQnJhbmNoO1xuICB0aGlzLmlzUmVtb3RlID0gaXNSZW1vdGVCcmFuY2hPckhFQUQgfHwgdGhpcy5pc1JlbW90ZVRhZztcbiAgdGhpcy5pc0xvY2FsID0gdGhpcy5pc0xvY2FsQnJhbmNoIHx8IHRoaXMuaXNMb2NhbFRhZztcbiAgaWYgKHRoaXMuaXNMb2NhbEJyYW5jaCkge1xuICAgIHRoaXMubG9jYWxSZWZOYW1lID0gdGhpcy5uYW1lLnNsaWNlKCdyZWZzL2hlYWRzLycubGVuZ3RoKTtcbiAgICB0aGlzLnJlZk5hbWUgPSB0aGlzLmxvY2FsUmVmTmFtZTtcbiAgfVxuICBpZiAodGhpcy5pc1JlbW90ZUJyYW5jaCkge1xuICAgIHRoaXMubG9jYWxSZWZOYW1lID0gdGhpcy5uYW1lLnNsaWNlKCdyZWZzL3JlbW90ZXMvJy5sZW5ndGgpO1xuICB9XG4gIGlmICh0aGlzLmlzTG9jYWxUYWcpIHtcbiAgICB0aGlzLmxvY2FsUmVmTmFtZSA9IHRoaXMubmFtZS5zbGljZSgndGFnOiByZWZzL3RhZ3MvJy5sZW5ndGgpO1xuICAgIHRoaXMucmVmTmFtZSA9IHRoaXMubG9jYWxSZWZOYW1lO1xuICB9XG4gIGlmICh0aGlzLmlzUmVtb3RlVGFnKSB7XG4gICAgdGhpcy5sb2NhbFJlZk5hbWUgPSB0aGlzLm5hbWUuc2xpY2UoJ3JlbW90ZS10YWc6ICcubGVuZ3RoKTtcbiAgfVxuICBpZiAodGhpcy5pc1JlbW90ZSkge1xuICAgIC8vIGdldCByaWQgb2YgdGhlIG9yaWdpbi8gcGFydCBvZiBvcmlnaW4vYnJhbmNobmFtZVxuICAgIHZhciBzID0gdGhpcy5sb2NhbFJlZk5hbWUuc3BsaXQoJy8nKTtcbiAgICB0aGlzLnJlbW90ZSA9IHNbMF07XG4gICAgdGhpcy5yZWZOYW1lID0gcy5zbGljZSgxKS5qb2luKCcvJyk7XG4gIH1cbiAgdGhpcy5zaG93ID0gdHJ1ZTtcbiAgdGhpcy5zZXJ2ZXIgPSB0aGlzLmdyYXBoLnNlcnZlcjtcbiAgdGhpcy5pc0RyYWdnaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMuY3VycmVudCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLmlzTG9jYWxCcmFuY2ggJiYgc2VsZi5ncmFwaC5jaGVja2VkT3V0QnJhbmNoKCkgPT0gc2VsZi5yZWZOYW1lO1xuICB9KTtcbiAgdGhpcy5jb2xvciA9IHRoaXMuX2NvbG9yRnJvbUhhc2hPZlN0cmluZyh0aGlzLm5hbWUpO1xuXG4gIHRoaXMubm9kZS5zdWJzY3JpYmUoZnVuY3Rpb24ob2xkTm9kZSkge1xuICAgIGlmIChvbGROb2RlKSBvbGROb2RlLmJyYW5jaGVzQW5kTG9jYWxUYWdzLnJlbW92ZShzZWxmKTtcbiAgfSwgbnVsbCwgXCJiZWZvcmVDaGFuZ2VcIik7XG4gIHRoaXMubm9kZS5zdWJzY3JpYmUoZnVuY3Rpb24obmV3Tm9kZSkge1xuICAgIGlmIChuZXdOb2RlKSBuZXdOb2RlLmJyYW5jaGVzQW5kTG9jYWxUYWdzLnB1c2goc2VsZik7XG4gIH0pXG59O1xubW9kdWxlLmV4cG9ydHMgPSBSZWZWaWV3TW9kZWw7XG5cblJlZlZpZXdNb2RlbC5wcm90b3R5cGUuX2NvbG9yRnJvbUhhc2hPZlN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICByZXR1cm4gJyMnICsgbWQ1KHN0cmluZykudG9TdHJpbmcoKS5zbGljZSgwLCA2KTtcbn1cblJlZlZpZXdNb2RlbC5wcm90b3R5cGUuZHJhZ1N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQodGhpcyk7XG4gIHRoaXMuaXNEcmFnZ2luZyh0cnVlKTtcbiAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xufVxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5kcmFnRW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQobnVsbCk7XG4gIHRoaXMuaXNEcmFnZ2luZyhmYWxzZSk7XG59XG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBjYWxsYmFja1dpdGhSZWZTZXQgPSBmdW5jdGlvbihlcnIsIHJlcykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVyciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhcmdldE5vZGUgPSBzZWxmLmdyYXBoLmdldE5vZGUodGFyZ2V0KTtcbiAgICAgIGlmIChzZWxmLmdyYXBoLmNoZWNrZWRPdXRCcmFuY2goKSA9PSBzZWxmLnJlZk5hbWUpIHtcbiAgICAgICAgc2VsZi5ncmFwaC5IRUFEcmVmKCkubm9kZSh0YXJnZXROb2RlKTtcbiAgICAgIH1cbiAgICAgIHNlbGYubm9kZSh0YXJnZXROb2RlKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuaXNMb2NhbCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQoKSkge1xuICAgICAgdGhpcy5zZXJ2ZXIucG9zdCgnL3Jlc2V0JywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoLCB0bzogdGFyZ2V0LCBtb2RlOiAnaGFyZCcgfSwgY2FsbGJhY2tXaXRoUmVmU2V0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNUYWcpIHtcbiAgICAgIHRoaXMuc2VydmVyLnBvc3QoJy90YWdzJywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoLCBuYW1lOiB0aGlzLnJlZk5hbWUsIHN0YXJ0UG9pbnQ6IHRhcmdldCwgZm9yY2U6IHRydWUgfSwgY2FsbGJhY2tXaXRoUmVmU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXJ2ZXIucG9zdCgnL2JyYW5jaGVzJywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoLCBuYW1lOiB0aGlzLnJlZk5hbWUsIHN0YXJ0UG9pbnQ6IHRhcmdldCwgZm9yY2U6IHRydWUgfSwgY2FsbGJhY2tXaXRoUmVmU2V0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHB1c2hSZXEgPSB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgsIHJlbW90ZTogdGhpcy5yZW1vdGUsIHJlZlNwZWM6IHRhcmdldCwgcmVtb3RlQnJhbmNoOiB0aGlzLnJlZk5hbWUgfTtcbiAgICB0aGlzLnNlcnZlci5wb3N0KCcvcHVzaCcsIHB1c2hSZXEsIGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyLmVycm9yQ29kZSA9PSAnbm9uLWZhc3QtZm9yd2FyZCcpIHtcbiAgICAgICAgICAgIHZhciBmb3JjZVB1c2hEaWFsb2cgPSBjb21wb25lbnRzLmNyZWF0ZSgneWVzbm9kaWFsb2cnLCB7IHRpdGxlOiAnRm9yY2UgcHVzaD8nLCBkZXRhaWxzOiAnVGhlIHJlbW90ZSBicmFuY2ggY2FuXFwndCBiZSBmYXN0LWZvcndhcmRlZC4nIH0pO1xuICAgICAgICAgICAgZm9yY2VQdXNoRGlhbG9nLmNsb3NlZC5hZGQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmICghZm9yY2VQdXNoRGlhbG9nLnJlc3VsdCgpKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgcHVzaFJlcS5mb3JjZSA9IHRydWU7XG4gICAgICAgICAgICAgIHNlbGYuc2VydmVyLnBvc3QoJy9wdXNoJywgcHVzaFJlcSwgY2FsbGJhY2tXaXRoUmVmU2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAncmVxdWVzdC1zaG93LWRpYWxvZycsIGRpYWxvZzogZm9yY2VQdXNoRGlhbG9nIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrV2l0aFJlZlNldChlcnIsIHJlcyk7XG4gICAgICB9KTtcbiAgfVxufVxuXG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVybCA9IHRoaXMuaXNUYWcgPyAnL3RhZ3MnIDogJy9icmFuY2hlcyc7XG4gIGlmICh0aGlzLmlzUmVtb3RlKSB1cmwgPSAnL3JlbW90ZScgKyB1cmw7XG4gIHRoaXMuc2VydmVyLmRlbCh1cmwsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCwgcmVtb3RlOiB0aGlzLmlzUmVtb3RlID8gdGhpcy5yZW1vdGUgOiBudWxsLCBuYW1lOiB0aGlzLnJlZk5hbWUgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIHNlbGYubm9kZSgpLnJlbW92ZVJlZihzZWxmKTtcbiAgICAgIHNlbGYuZ3JhcGgucmVmc0J5UmVmTmFtZVtzZWxmLm5hbWVdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKCk7XG4gICAgc2VsZi5ncmFwaC5sb2FkTm9kZXNGcm9tQXBpKCk7XG4gICAgaWYgKHVybCA9PSAnL3JlbW90ZS90YWdzJykge1xuICAgICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAncmVxdWVzdC1mZXRjaC10YWdzJyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAnYnJhbmNoLXVwZGF0ZWQnIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cblJlZlZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0UmVtb3RlUmVmID0gZnVuY3Rpb24ocmVtb3RlKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoLmdldFJlZih0aGlzLmdldFJlbW90ZVJlZkZ1bGxOYW1lKHJlbW90ZSksIGZhbHNlKTtcbn1cblxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5nZXRSZW1vdGVSZWZGdWxsTmFtZSA9IGZ1bmN0aW9uKHJlbW90ZSkge1xuICBpZiAodGhpcy5pc0xvY2FsQnJhbmNoKSByZXR1cm4gJ3JlZnMvcmVtb3Rlcy8nICsgcmVtb3RlICsgJy8nICsgdGhpcy5yZWZOYW1lO1xuICBpZiAodGhpcy5pc0xvY2FsVGFnKSByZXR1cm4gJ3JlbW90ZS10YWc6ICcgKyByZW1vdGUgKyAnLycgKyB0aGlzLnJlZk5hbWU7XG4gIHJldHVybiBudWxsO1xufVxuXG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLmNhbkJlUHVzaGVkID0gZnVuY3Rpb24ocmVtb3RlKSB7XG4gIGlmICghdGhpcy5pc0xvY2FsKSByZXR1cm4gZmFsc2U7XG4gIHZhciByZW1vdGVSZWYgPSB0aGlzLmdldFJlbW90ZVJlZihyZW1vdGUpO1xuICBpZiAoIXJlbW90ZVJlZikgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0aGlzLm5vZGUoKSAhPSByZW1vdGVSZWYubm9kZSgpO1xufVxuXG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLmNyZWF0ZVJlbW90ZVJlZiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZXJ2ZXIucG9zdCgnL3B1c2gnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgsIHJlbW90ZTogdGhpcy5ncmFwaC5jdXJyZW50UmVtb3RlKCksXG4gICAgICByZWZTcGVjOiB0aGlzLnJlZk5hbWUsIHJlbW90ZUJyYW5jaDogdGhpcy5yZWZOYW1lIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHZhciBuZXdSZWYgPSBzZWxmLmdyYXBoLmdldFJlZihcInJlZnMvcmVtb3Rlcy9cIiArIHNlbGYuZ3JhcGguY3VycmVudFJlbW90ZSgpICsgXCIvXCIgKyBzZWxmLnJlZk5hbWUpO1xuICAgICAgICAgIHNlbGYubm9kZSgpLmJyYW5jaGVzQW5kTG9jYWxUYWdzLnB1c2gobmV3UmVmKTtcbiAgICAgICAgICBuZXdSZWYubm9kZShzZWxmLm5vZGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pO1xufVxuIiwidmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcbnZhciBjb21wb25lbnRzID0gcmVxdWlyZSgndW5naXQtY29tcG9uZW50cycpO1xudmFyIEdpdE5vZGVWaWV3TW9kZWwgPSByZXF1aXJlKCcuL2dpdC1ub2RlJyk7XG52YXIgR2l0UmVmVmlld01vZGVsID0gcmVxdWlyZSgnLi9naXQtcmVmJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xudmFyIEVkZ2VWaWV3TW9kZWwgPSByZXF1aXJlKCcuL2VkZ2UnKTtcblxuY29tcG9uZW50cy5yZWdpc3RlcignZ3JhcGgnLCBmdW5jdGlvbihhcmdzKSB7XG4gIHJldHVybiBuZXcgR3JhcGhWaWV3TW9kZWwoYXJncy5zZXJ2ZXIsIGFyZ3MucmVwb1BhdGgpO1xufSk7XG5cbmZ1bmN0aW9uIEdyYXBoVmlld01vZGVsKHNlcnZlciwgcmVwb1BhdGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnJlcG9QYXRoID0gcmVwb1BhdGg7XG4gIHRoaXMubWF4Tk5vZGVzID0gMjU7XG4gIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICB0aGlzLmN1cnJlbnRSZW1vdGUgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMubm9kZXNMb2FkZXIgPSBjb21wb25lbnRzLmNyZWF0ZSgncHJvZ3Jlc3NCYXInLCB7XG4gICAgcHJlZGljdGlvbk1lbW9yeUtleTogJ2dpdGdyYXBoLScgKyBzZWxmLnJlcG9QYXRoLFxuICAgIGZhbGxiYWNrUHJlZGljdGVkVGltZU1zOiAxMDAwLFxuICAgIHRlbXBvcmFyeTogdHJ1ZVxuICB9KTtcbiAgdGhpcy5ub2RlcyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICB0aGlzLmVkZ2VzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHRoaXMucmVmcyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICB0aGlzLm5vZGVzQnlJZCA9IHt9O1xuICB0aGlzLnJlZnNCeVJlZk5hbWUgPSB7fTtcbiAgdGhpcy5jaGVja2VkT3V0QnJhbmNoID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmNoZWNrZWRPdXRSZWYgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5jaGVja2VkT3V0QnJhbmNoKCkgPyBzZWxmLmdldFJlZigncmVmcy9oZWFkcy8nICsgc2VsZi5jaGVja2VkT3V0QnJhbmNoKCkpIDogbnVsbDtcbiAgfSk7XG4gIHRoaXMuSEVBRHJlZiA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5IRUFEID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuSEVBRHJlZigpID8gc2VsZi5IRUFEcmVmKCkubm9kZSgpIDogdW5kZWZpbmVkO1xuICB9KTtcbiAgdGhpcy5jb21taXROb2RlQ29sb3IgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5IRUFEKCkgPyBzZWxmLkhFQUQoKS5jb2xvcigpIDogJyM0QTRBNEEnO1xuICB9KTtcbiAgdGhpcy5jb21taXROb2RlRWRnZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmICghc2VsZi5IRUFEKCkgfHwgIXNlbGYuSEVBRCgpLmN4KCkgfHwgIXNlbGYuSEVBRCgpLmN5KCkpIHJldHVybjtcbiAgICByZXR1cm4gXCJNIDYxMCA2OCBMIFwiICsgc2VsZi5IRUFEKCkuY3goKSArIFwiIFwiICsgc2VsZi5IRUFEKCkuY3koKTtcbiAgfSk7XG4gIHRoaXMuc2hvd0NvbW1pdE5vZGUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dCA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5lZGdlc0J5SWQgPSB7fTtcbiAgdGhpcy5zY3JvbGxlZFRvRW5kID0gXy5kZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICBzZWxmLm1heE5Ob2RlcyA9IHNlbGYubWF4Tk5vZGVzICsgMjU7XG4gICAgc2VsZi5sb2FkTm9kZXNGcm9tQXBpKCk7XG4gIH0sIDUwMCwgdHJ1ZSk7XG4gIHRoaXMuZGltQ29tbWl0ID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMuY29tbWl0T3BhY2l0eSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5kaW1Db21taXQoKSA/IDAuMSA6IDE7IH0pO1xuICB0aGlzLmhlaWdoc3RCcmFuY2hPcmRlciA9IDA7XG4gIHRoaXMuaG92ZXJHcmFwaEFjdGlvbkdyYXBoaWMgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuaG92ZXJHcmFwaEFjdGlvbkdyYXBoaWMuc3Vic2NyaWJlKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmRlc3Ryb3kpXG4gICAgICB2YWx1ZS5kZXN0cm95KCk7XG4gIH0sIG51bGwsICdiZWZvcmVDaGFuZ2UnKTtcblxuICB0aGlzLmhvdmVyR3JhcGhBY3Rpb24gPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuaG92ZXJHcmFwaEFjdGlvbi5zdWJzY3JpYmUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUuY3JlYXRlSG92ZXJHcmFwaGljKSB7XG4gICAgICBzZWxmLmhvdmVyR3JhcGhBY3Rpb25HcmFwaGljKHZhbHVlLmNyZWF0ZUhvdmVyR3JhcGhpYygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5ob3ZlckdyYXBoQWN0aW9uR3JhcGhpYyhudWxsKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMubG9hZE5vZGVzRnJvbUFwaVRocm90dGxlZCA9IF8udGhyb3R0bGUodGhpcy5sb2FkTm9kZXNGcm9tQXBpLmJpbmQodGhpcyksIDUwMCk7XG4gIHRoaXMudXBkYXRlQnJhbmNoZXNUaHJvdHRsZWQgPSBfLnRocm90dGxlKHRoaXMudXBkYXRlQnJhbmNoZXMuYmluZCh0aGlzKSwgNTAwKTtcbiAgdGhpcy5sb2FkTm9kZXNGcm9tQXBpVGhyb3R0bGVkKCk7XG4gIHRoaXMudXBkYXRlQnJhbmNoZXNUaHJvdHRsZWQoKTtcbiAgdGhpcy5ncmFwaFdpZHRoID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmdyYXBoSGVpZ2h0ID0ga28ub2JzZXJ2YWJsZSgpO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUudXBkYXRlTm9kZSA9IGZ1bmN0aW9uKHBhcmVudEVsZW1lbnQpIHtcbiAga28ucmVuZGVyVGVtcGxhdGUoJ2dyYXBoJywgdGhpcywge30sIHBhcmVudEVsZW1lbnQpO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uKHNoYTEsIGxvZ0VudHJ5KSB7XG4gIHZhciBub2RlVmlld01vZGVsID0gdGhpcy5ub2Rlc0J5SWRbc2hhMV07XG4gIGlmICghbm9kZVZpZXdNb2RlbCkgbm9kZVZpZXdNb2RlbCA9IHRoaXMubm9kZXNCeUlkW3NoYTFdID0gbmV3IEdpdE5vZGVWaWV3TW9kZWwodGhpcywgc2hhMSk7XG4gIGlmIChsb2dFbnRyeSkgbm9kZVZpZXdNb2RlbC5zZXREYXRhKGxvZ0VudHJ5KTtcbiAgcmV0dXJuIG5vZGVWaWV3TW9kZWw7XG59XG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0UmVmID0gZnVuY3Rpb24ocmVmLCBjb25zdHJ1Y3RJZlVuYXZhaWxhYmxlKSB7XG4gIGlmIChjb25zdHJ1Y3RJZlVuYXZhaWxhYmxlID09PSB1bmRlZmluZWQpIGNvbnN0cnVjdElmVW5hdmFpbGFibGUgPSB0cnVlO1xuICB2YXIgcmVmVmlld01vZGVsID0gdGhpcy5yZWZzQnlSZWZOYW1lW3JlZl07XG4gIGlmICghcmVmVmlld01vZGVsICYmIGNvbnN0cnVjdElmVW5hdmFpbGFibGUpIHtcbiAgICByZWZWaWV3TW9kZWwgPSB0aGlzLnJlZnNCeVJlZk5hbWVbcmVmXSA9IG5ldyBHaXRSZWZWaWV3TW9kZWwocmVmLCB0aGlzKTtcbiAgICB0aGlzLnJlZnMucHVzaChyZWZWaWV3TW9kZWwpO1xuICAgIGlmIChyZWZWaWV3TW9kZWwubmFtZSA9PT0gJ0hFQUQnKSB7XG4gICAgICB0aGlzLkhFQURyZWYocmVmVmlld01vZGVsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZlZpZXdNb2RlbDtcbn1cblxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLmxvYWROb2Rlc0Zyb21BcGkgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5ub2Rlc0xvYWRlci5zdGFydCgpO1xuICB0aGlzLnNlcnZlci5nZXRQcm9taXNlKCcvbG9nJywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoLCBsaW1pdDogdGhpcy5tYXhOTm9kZXMgfSlcbiAgICAudGhlbihmdW5jdGlvbihub2Rlcykge1xuICAgICAgbm9kZXMgPSBzZWxmLmNvbXB1dGVOb2RlKG5vZGVzLm1hcChmdW5jdGlvbihsb2dFbnRyeSkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmdldE5vZGUobG9nRW50cnkuc2hhMSwgbG9nRW50cnkpO1xuICAgICAgICB9KSk7XG5cbiAgICAgIHZhciBlZGdlcyA9IFtdO1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50cygpLmZvckVhY2goZnVuY3Rpb24ocGFyZW50U2hhMSkge1xuICAgICAgICAgIGVkZ2VzLnB1c2goc2VsZi5nZXRFZGdlKG5vZGUuc2hhMSwgcGFyZW50U2hhMSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5yZW5kZXIoKTtcbiAgICAgIH0pO1xuXG4gICAgICBzZWxmLmVkZ2VzKGVkZ2VzKTtcbiAgICAgIHNlbGYubm9kZXMobm9kZXMpO1xuXG4gICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxmLmdyYXBoSGVpZ2h0KG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLmN5KCkgKyA4MCk7XG4gICAgICB9XG4gICAgICBzZWxmLmdyYXBoV2lkdGgoMTAwMCArIChzZWxmLmhlaWdoc3RCcmFuY2hPcmRlciAqIDkwKSk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYubm9kZXNMb2FkZXIuc3RvcCgpO1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgIH0pO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUudHJhdmVyc2VOb2RlTGVmdFBhcmVudHMgPSBmdW5jdGlvbihub2RlLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayhub2RlKTtcbiAgdmFyIHBhcmVudCA9IHRoaXMubm9kZXNCeUlkW25vZGUucGFyZW50cygpWzBdXTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHRoaXMudHJhdmVyc2VOb2RlTGVmdFBhcmVudHMocGFyZW50LCBjYWxsYmFjayk7XG4gIH1cbn1cblxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLmNvbXB1dGVOb2RlID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghbm9kZXMpIHtcbiAgICBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgfVxuXG4gIHRoaXMubWFya05vZGVzSWRlb2xvZ2ljYWxCcmFuY2hlcyh0aGlzLnJlZnMoKSwgbm9kZXMsIHRoaXMubm9kZXNCeUlkKTtcblxuICB2YXIgdXBkYXRlVGltZVN0YW1wID0gbW9tZW50KCkudmFsdWVPZigpO1xuICBpZiAodGhpcy5IRUFEKCkpIHtcbiAgICB0aGlzLnRyYXZlcnNlTm9kZUxlZnRQYXJlbnRzKHRoaXMuSEVBRCgpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLmFuY2VzdG9yT2ZIRUFEVGltZVN0YW1wID0gdXBkYXRlVGltZVN0YW1wO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gRmlsdGVyIG91dCBub2RlcyB3aGljaCBkb2Vzbid0IGhhdmUgYSBicmFuY2ggKHN0YWdpbmcgYW5kIG9ycGhhbmVkIG5vZGVzKVxuICBub2RlcyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbihub2RlKSB7IHJldHVybiAobm9kZS5pZGVvbG9naWNhbEJyYW5jaCgpICYmICFub2RlLmlkZW9sb2dpY2FsQnJhbmNoKCkuaXNTdGFzaCkgfHwgbm9kZS5hbmNlc3Rvck9mSEVBRFRpbWVTdGFtcCA9PSB1cGRhdGVUaW1lU3RhbXA7IH0pXG5cbiAgdmFyIGJyYW5jaFNsb3RzID0gW107XG5cbiAgLy8gVGhlbiBpdGVyYXRlIGZyb20gdGhlIGJvdHRvbSB0byBmaXggdGhlIG9yZGVycyBvZiB0aGUgYnJhbmNoZXNcbiAgZm9yICh2YXIgaSA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAobm9kZS5hbmNlc3Rvck9mSEVBRFRpbWVTdGFtcCA9PSB1cGRhdGVUaW1lU3RhbXApIGNvbnRpbnVlO1xuICAgIHZhciBpZGVvbG9naWNhbEJyYW5jaCA9IG5vZGUuaWRlb2xvZ2ljYWxCcmFuY2goKTtcblxuICAgIC8vIEZpcnN0IG9jY3VyZW5jZSBvZiB0aGUgYnJhbmNoLCBmaW5kIGFuIGVtcHR5IHNsb3QgZm9yIHRoZSBicmFuY2hcbiAgICBpZiAoaWRlb2xvZ2ljYWxCcmFuY2gubGFzdFNsb3R0ZWRUaW1lU3RhbXAgIT0gdXBkYXRlVGltZVN0YW1wKSB7XG4gICAgICBpZGVvbG9naWNhbEJyYW5jaC5sYXN0U2xvdHRlZFRpbWVTdGFtcCA9IHVwZGF0ZVRpbWVTdGFtcDtcbiAgICAgIHZhciBzbG90ID0gYnJhbmNoU2xvdHMuaW5kZXhPZih1bmRlZmluZWQpO1xuICAgICAgaWYgKHNsb3QgPT09IC0xKSB7XG4gICAgICAgIGJyYW5jaFNsb3RzLnB1c2goaWRlb2xvZ2ljYWxCcmFuY2gpO1xuICAgICAgICBzbG90ID0gYnJhbmNoU2xvdHMubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIGlkZW9sb2dpY2FsQnJhbmNoLmJyYW5jaE9yZGVyID0gc2xvdDtcbiAgICAgIGJyYW5jaFNsb3RzW3Nsb3RdID0gc2xvdDtcbiAgICB9XG5cbiAgICBub2RlLmJyYW5jaE9yZGVyKGlkZW9sb2dpY2FsQnJhbmNoLmJyYW5jaE9yZGVyKTtcbiAgICBzZWxmLmhlaWdoc3RCcmFuY2hPcmRlciA9IE1hdGgubWF4KHNlbGYuaGVpZ2hzdEJyYW5jaE9yZGVyLCBub2RlLmJyYW5jaE9yZGVyKCkpO1xuICB9XG5cbiAgdmFyIHByZXZOb2RlO1xuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLmJyYW5jaE9yZGVyKGJyYW5jaFNsb3RzLmxlbmd0aCAtIG5vZGUuYnJhbmNoT3JkZXIoKSk7XG4gICAgbm9kZS5hbmNlc3Rvck9mSEVBRChub2RlLmFuY2VzdG9yT2ZIRUFEVGltZVN0YW1wID09IHVwZGF0ZVRpbWVTdGFtcCk7XG4gICAgbm9kZS5hYm92ZU5vZGUgPSBwcmV2Tm9kZTtcbiAgICBpZiAocHJldk5vZGUpIHByZXZOb2RlLmJlbG93Tm9kZSA9IG5vZGU7XG4gICAgcHJldk5vZGUgPSBub2RlO1xuICB9KTtcblxuICByZXR1cm4gbm9kZXM7XG59XG5cbkdyYXBoVmlld01vZGVsLnByb3RvdHlwZS5nZXRFZGdlID0gZnVuY3Rpb24obm9kZUFzaGExLCBub2RlQnNoYTEpIHtcbiAgdmFyIGlkID0gbm9kZUFzaGExICsgJy0nICsgbm9kZUJzaGExO1xuICB2YXIgZWRnZSA9IHRoaXMuZWRnZXNCeUlkW2lkXTtcbiAgaWYgKCFlZGdlKSB7XG4gICAgZWRnZSA9IHRoaXMuZWRnZXNCeUlkW2lkXSA9IG5ldyBFZGdlVmlld01vZGVsKHRoaXMsIG5vZGVBc2hhMSwgbm9kZUJzaGExKTtcbiAgfVxuICByZXR1cm4gZWRnZTtcbn1cblxuR3JhcGhWaWV3TW9kZWwuX21hcmtJZGVvbG9naWNhbFN0YW1wID0gMDtcbkdyYXBoVmlld01vZGVsLnByb3RvdHlwZS5tYXJrTm9kZXNJZGVvbG9naWNhbEJyYW5jaGVzID0gZnVuY3Rpb24ocmVmcywgbm9kZXMsIG5vZGVzQnlJZCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlZnMgPSByZWZzLmZpbHRlcihmdW5jdGlvbihyKSB7IHJldHVybiAhIXIubm9kZSgpOyB9KTtcbiAgcmVmcyA9IHJlZnMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEuaXNMb2NhbCAmJiAhYi5pc0xvY2FsKSByZXR1cm4gLTE7XG4gICAgaWYgKGIuaXNMb2NhbCAmJiAhYS5pc0xvY2FsKSByZXR1cm4gMTtcbiAgICBpZiAoYS5pc0JyYW5jaCAmJiAhYi5pc0JyYW5jaCkgcmV0dXJuIC0xO1xuICAgIGlmIChiLmlzQnJhbmNoICYmICFhLmlzQnJhbmNoKSByZXR1cm4gMTtcbiAgICBpZiAoYS5pc0hFQUQgJiYgIWIuaXNIRUFEKSByZXR1cm4gMTtcbiAgICBpZiAoIWEuaXNIRUFEICYmIGIuaXNIRUFEKSByZXR1cm4gLTE7XG4gICAgaWYgKGEuaXNTdGFzaCAmJiAhYi5pc1N0YXNoKSByZXR1cm4gMTtcbiAgICBpZiAoYi5pc1N0YXNoICYmICFhLmlzU3Rhc2gpIHJldHVybiAtMTtcbiAgICBpZiAoYS5ub2RlKCkgJiYgYS5ub2RlKCkuZGF0ZSAmJiBiLm5vZGUoKSAmJiBiLm5vZGUoKS5kYXRlKVxuICAgICAgcmV0dXJuIGIubm9kZSgpLmRhdGUgLSBhLm5vZGUoKS5kYXRlO1xuICAgIHJldHVybiBhLnJlZk5hbWUgPCBiLnJlZk5hbWUgPyAtMSA6IDE7XG4gIH0pO1xuICB2YXIgc3RhbXAgPSBHcmFwaFZpZXdNb2RlbC5fbWFya0lkZW9sb2dpY2FsU3RhbXArKztcbiAgcmVmcy5mb3JFYWNoKGZ1bmN0aW9uKHJlZikge1xuICAgIHNlbGYudHJhdmVyc2VOb2RlUGFyZW50cyhyZWYubm9kZSgpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZS5zdGFtcCA9PSBzdGFtcCkgcmV0dXJuIGZhbHNlO1xuICAgICAgbm9kZS5zdGFtcCA9IHN0YW1wO1xuICAgICAgbm9kZS5pZGVvbG9naWNhbEJyYW5jaChyZWYpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUudHJhdmVyc2VOb2RlUGFyZW50cyA9IGZ1bmN0aW9uKG5vZGUsIGNhbGxiYWNrKSB7XG4gIGlmICghY2FsbGJhY2sobm9kZSkpIHJldHVybiBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnBhcmVudHMoKS5sZW5ndGg7IGkrKykge1xuICAgIC8vIGlmIHBhcmVudCwgdHJhdmVycyBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5ub2Rlc0J5SWRbbm9kZS5wYXJlbnRzKClbaV1dO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHRoaXMudHJhdmVyc2VOb2RlUGFyZW50cyhwYXJlbnQsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLmhhbmRsZUJ1YmJsZWRDbGljayA9IGZ1bmN0aW9uKGVsZW0sIGV2ZW50KSB7XG4gIC8vIElmIHRoZSBjbGlja2VkIGVsZW1lbnQgaXMgYm91bmQgdG8gdGhlIGN1cnJlbnQgYWN0aW9uIGNvbnRleHQsXG4gIC8vIHRoZW4gbGV0J3Mgbm90IGRlc2VsZWN0IGl0LlxuICBpZiAoa28uZGF0YUZvcihldmVudC50YXJnZXQpID09PSB0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkpIHJldHVybjtcbiAgaWYgKHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQoKSAmJiB0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgaW5zdGFuY2VvZiBHaXROb2RlVmlld01vZGVsKSB7XG4gICAgdGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dCgpLnRvZ2dsZVNlbGVjdGVkKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dChudWxsKTtcbiAgfVxuICAvLyBJZiB0aGUgY2xpY2sgd2FzIG9uIGFuIGlucHV0IGVsZW1lbnQsIHRoZW4gbGV0J3MgYWxsb3cgdGhlIGRlZmF1bHQgYWN0aW9uIHRvIHByb2NlZWQuXG4gIC8vIFRoaXMgaXMgZXNwZWNpYWxseSBuZWVkZWQgc2luY2UgZm9yIHNvbWUgc3RyYW5nZSByZWFzb24gYW55IHN1Ym1pdCAoaWUuIGVudGVyIGluIGEgdGV4dGJveClcbiAgLy8gd2lsbCB0cmlnZ2VyIGEgY2xpY2sgZXZlbnQgb24gdGhlIHN1Ym1pdCBpbnB1dCBvZiB0aGUgZm9ybSwgd2hpY2ggd2lsbCBlbmQgdXAgaGVyZSxcbiAgLy8gYW5kIGlmIHdlIGRvbid0IHJldHVybiB0cnVlLCB0aGVuIHRoZSBzdWJtaXQgZXZlbnQgaXMgbmV2ZXIgZmlyZWQsIGJyZWFraW5nIHN0dWZmLlxuICBpZiAoZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID09PSAnSU5QVVQnKSByZXR1cm4gdHJ1ZTtcbn1cblxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLm9uUHJvZ3JhbUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmV2ZW50ID09ICdnaXQtZGlyZWN0b3J5LWNoYW5nZWQnKSB7XG4gICAgdGhpcy5sb2FkTm9kZXNGcm9tQXBpVGhyb3R0bGVkKCk7XG4gICAgdGhpcy51cGRhdGVCcmFuY2hlc1Rocm90dGxlZCgpO1xuICB9IGVsc2UgaWYgKGV2ZW50LmV2ZW50ID09ICdyZXF1ZXN0LWFwcC1jb250ZW50LXJlZnJlc2gnKSB7XG4gICAgdGhpcy5sb2FkTm9kZXNGcm9tQXBpVGhyb3R0bGVkKCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQuZXZlbnQgPT0gJ3JlbW90ZS10YWdzLXVwZGF0ZScpIHtcbiAgICB0aGlzLnNldFJlbW90ZVRhZ3MoZXZlbnQudGFncyk7XG4gIH0gZWxzZSBpZiAoZXZlbnQuZXZlbnQgPT0gJ2N1cnJlbnQtcmVtb3RlLWNoYW5nZWQnKSB7XG4gICAgdGhpcy5jdXJyZW50UmVtb3RlKGV2ZW50Lm5ld1JlbW90ZSk7XG4gIH0gZWxzZSBpZiAoZXZlbnQuZXZlbnQgPT0gJ2dyYXBoLXJlbmRlcicpIHtcbiAgICB0aGlzLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLnJlbmRlcigpO1xuICAgIH0pO1xuICB9XG59XG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUudXBkYXRlQnJhbmNoZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlcnZlci5nZXQoJy9jaGVja291dCcsIHsgcGF0aDogdGhpcy5yZXBvUGF0aCB9LCBmdW5jdGlvbihlcnIsIGJyYW5jaCkge1xuICAgIGlmIChlcnIgJiYgZXJyLmVycm9yQ29kZSA9PSAnbm90LWEtcmVwb3NpdG9yeScpIHJldHVybiB0cnVlO1xuICAgIGlmIChlcnIpIHJldHVybjtcbiAgICBzZWxmLmNoZWNrZWRPdXRCcmFuY2goYnJhbmNoKTtcbiAgfSk7XG59XG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuc2V0UmVtb3RlVGFncyA9IGZ1bmN0aW9uKHJlbW90ZVRhZ3MpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbm9kZUlkc1RvUmVtb3RlVGFncyA9IHt9O1xuICByZW1vdGVUYWdzLmZvckVhY2goZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKHJlZi5uYW1lLmluZGV4T2YoJ157fScpICE9IC0xKSB7XG4gICAgICB2YXIgdGFnUmVmID0gcmVmLm5hbWUuc2xpY2UoMCwgcmVmLm5hbWUubGVuZ3RoIC0gJ157fScubGVuZ3RoKTtcbiAgICAgIHZhciBuYW1lID0gJ3JlbW90ZS10YWc6ICcgKyByZWYucmVtb3RlICsgJy8nICsgdGFnUmVmLnNwbGl0KCcvJylbMl07XG4gICAgICB2YXIgcmVmVmlld01vZGVsID0gc2VsZi5nZXRSZWYobmFtZSk7XG4gICAgICB2YXIgbm9kZSA9IHNlbGYuZ2V0Tm9kZShyZWYuc2hhMSk7XG4gICAgICByZWZWaWV3TW9kZWwubm9kZShub2RlKTtcblxuICAgICAgbm9kZUlkc1RvUmVtb3RlVGFnc1tyZWYuc2hhMV0gPSBub2RlSWRzVG9SZW1vdGVUYWdzW3JlZi5zaGExXSB8fCBbXTtcbiAgICAgIG5vZGVJZHNUb1JlbW90ZVRhZ3NbcmVmLnNoYTFdLnB1c2gocmVmVmlld01vZGVsKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZvcih2YXIga2V5IGluIHRoaXMubm9kZXNCeUlkKSB7XG4gICAgdGhpcy5ub2Rlc0J5SWRba2V5XS5yZW1vdGVUYWdzKG5vZGVJZHNUb1JlbW90ZVRhZ3Nba2V5XSB8fCBbXSk7XG4gIH1cbn1cbkdyYXBoVmlld01vZGVsLnByb3RvdHlwZS5jaGVja0hlYWRNb3ZlID0gZnVuY3Rpb24odG9Ob2RlKSB7XG4gIGlmICh0aGlzLkhFQUQoKSA9PT0gdG9Ob2RlKSB7XG4gICAgdGhpcy5IRUFEcmVmLm5vZGUodG9Ob2RlKTtcbiAgfVxufVxuIiwidmFyIGdldEVkZ2VNb2RlbFdpdGhEID0gZnVuY3Rpb24oZCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlRGFzaGFycmF5LCBtYXJrZXJFbmQpIHtcbiAgcmV0dXJuIHsgZDogZCxcbiAgICAgICAgICBzdHJva2U6IHN0cm9rZSA/IHN0cm9rZSA6ICcjNEE0QTRBJyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGggPyBzdHJva2VXaWR0aCA6ICc4JyxcbiAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSA/IHN0cm9rZURhc2hhcnJheSA6ICcxMCwgNScsXG4gICAgICAgICAgbWFya2VyRW5kOiBtYXJrZXJFbmQgPyBtYXJrZXJFbmQgOiAnJyB9O1xufVxuXG52YXIgZ2V0RWRnZU1vZGVsID0gZnVuY3Rpb24oc2N4LCBzY3ksIHRjeCwgdGN5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VEYXNoYXJyYXksIG1hcmtlckVuZCkge1xuICByZXR1cm4gZ2V0RWRnZU1vZGVsV2l0aEQoXCJNIFwiICsgc2N4ICsgXCIgXCIgKyBzY3kgKyBcIiBMIFwiICsgdGN4ICsgXCIgXCIgKyB0Y3ksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZURhc2hhcnJheSwgbWFya2VyRW5kKTtcbn1cblxudmFyIGdldE5vZGVNb2RlbCA9IGZ1bmN0aW9uKGN4LCBjeSwgciwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlRGFzaGFycmF5KSB7XG4gIHJldHVybiB7IGN4OiBjeCxcbiAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgcjogcixcbiAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgIHN0cm9rZTogc3Ryb2tlID8gc3Ryb2tlIDogJyM0MURFM0MnLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCA/IHN0cm9rZVdpZHRoIDogJzgnLFxuICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5ID8gc3Ryb2tlRGFzaGFycmF5IDogJzEwLCA1JyB9O1xufVxuXG5mdW5jdGlvbiBIb3ZlclZpZXdNb2RlbCgpIHtcbiAgdGhpcy5iZ0VkZ2VzID0gW107XG4gIHRoaXMubm9kZXMgPSBbXTtcbiAgdGhpcy5mZ0VkZ2VzID0gW107XG59XG5cbmZ1bmN0aW9uIE1lcmdlVmlld01vZGVsKGdyYXBoLCBoZWFkTm9kZSwgbm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEhvdmVyVmlld01vZGVsLmNhbGwodGhpcyk7XG4gIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5iZ0VkZ2VzID0gWyBnZXRFZGdlTW9kZWwoaGVhZE5vZGUuY3goKSwgKGhlYWROb2RlLmN5KCkgLSAxMTApLCBoZWFkTm9kZS5jeCgpLCBoZWFkTm9kZS5jeSgpKSxcbiAgICAgICAgICAgICAgICBnZXRFZGdlTW9kZWwoaGVhZE5vZGUuY3goKSwgKGhlYWROb2RlLmN5KCkgLSAxMTApLCBub2RlLmN4KCksIG5vZGUuY3koKSkgXTtcbiAgdGhpcy5ub2RlcyA9IFsgZ2V0Tm9kZU1vZGVsKGhlYWROb2RlLmN4KCksIGhlYWROb2RlLmN5KCkgLSAxMTAsIE1hdGgubWF4KGhlYWROb2RlLnIoKSwgbm9kZS5yKCkpLCAnIzI1MjgzMycsICcjNDFERTNDJywgJzgnLCAnMTAsIDUnKSBdO1xuXG4gIGdyYXBoLmRpbUNvbW1pdCh0cnVlKTtcbn1cbmV4cG9ydHMuTWVyZ2VWaWV3TW9kZWwgPSBNZXJnZVZpZXdNb2RlbDtcbk1lcmdlVmlld01vZGVsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ3JhcGguZGltQ29tbWl0KGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gUmViYXNlVmlld01vZGVsKG9udG8sIG5vZGVzVGhhdFdpbGxNb3ZlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgSG92ZXJWaWV3TW9kZWwuY2FsbCh0aGlzKTtcbiAgbm9kZXNUaGF0V2lsbE1vdmUgPSBub2Rlc1RoYXRXaWxsTW92ZS5zbGljZSgwLCAtMSk7XG5cbiAgaWYgKG5vZGVzVGhhdFdpbGxNb3ZlLmxlbmd0aCA9PSAwKSByZXR1cm47XG5cbiAgdGhpcy5iZ0VkZ2VzLnB1c2goZ2V0RWRnZU1vZGVsKG9udG8uY3goKSwgb250by5jeSgpLCBvbnRvLmN4KCksIG9udG8uY3koKSAtIDYwKSk7XG4gIG5vZGVzVGhhdFdpbGxNb3ZlLmZvckVhY2goZnVuY3Rpb24obm9kZSwgaSkge1xuICAgIHZhciBjeSA9IG9udG8uY3koKSArICgtOTAgKiAoaSArIDEpKTtcbiAgICBzZWxmLm5vZGVzLnB1c2goZ2V0Tm9kZU1vZGVsKG9udG8uY3goKSwgY3ksIDI4LCAndHJhbnNwYXJlbnQnKSk7XG4gICAgaWYgKGkgKyAxIDwgbm9kZXNUaGF0V2lsbE1vdmUubGVuZ3RoKSB7XG4gICAgICBzZWxmLmJnRWRnZXMucHVzaChnZXRFZGdlTW9kZWwob250by5jeCgpLCAoY3kgLSAyNSksIG9udG8uY3goKSwgKGN5IC0gNjUpKSk7XG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydHMuUmViYXNlVmlld01vZGVsID0gUmViYXNlVmlld01vZGVsO1xuXG5mdW5jdGlvbiBSZXNldFZpZXdNb2RlbChub2Rlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEhvdmVyVmlld01vZGVsLmNhbGwodGhpcyk7XG5cbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgc2VsZi5mZ0VkZ2VzLnB1c2goZ2V0RWRnZU1vZGVsV2l0aEQobm9kZS5nZXRMZWZ0VG9SaWdodFN0cmlrZSgpLCAncmdiKDI1NSwgMTI5LCAzMSknLCAnOCcsICcwLCAwJykpXG4gICAgc2VsZi5mZ0VkZ2VzLnB1c2goZ2V0RWRnZU1vZGVsV2l0aEQobm9kZS5nZXRSaWdodFRvTGVmdFN0cmlrZSgpLCAncmdiKDI1NSwgMTI5LCAzMSknLCAnOCcsICcwLCAwJykpO1xuICB9KTtcbn1cbmV4cG9ydHMuUmVzZXRWaWV3TW9kZWwgPSBSZXNldFZpZXdNb2RlbDtcblxuZnVuY3Rpb24gUHVzaFZpZXdNb2RlbChmcm9tTm9kZSwgdG9Ob2RlKSB7XG4gIEhvdmVyVmlld01vZGVsLmNhbGwodGhpcyk7XG4gIHRoaXMuZmdFZGdlcyA9IFtnZXRFZGdlTW9kZWwoZnJvbU5vZGUuY3goKSwgZnJvbU5vZGUuY3koKSwgdG9Ob2RlLmN4KCksICh0b05vZGUuY3koKSArIDQwKSwgJ3JnYig2MSwgMTM5LCAyNTUpJywgJzE1JywgJzEwLCA1JywgJ3VybCgjcHVzaEFycm93RW5kKScgKV07XG59XG5leHBvcnRzLlB1c2hWaWV3TW9kZWwgPSBQdXNoVmlld01vZGVsO1xuIiwidmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxudmFyIFNlbGVjdGFibGUgPSBmdW5jdGlvbihncmFwaCkge1xuICB0aGlzLnNlbGVjdGVkID0ga28uY29tcHV0ZWQoe1xuICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgPT0gdGhpcztcbiAgICB9LFxuICAgIHdyaXRlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIC8vIHZhbCBpcyB0aGlzIGlmIHdlJ3JlIGNhbGxlZCBmcm9tIGEgY2xpY2sga28gYmluZGluZ1xuICAgICAgaWYgKHZhbCA9PT0gdGhpcyB8fCB2YWwgPT09IHRydWUpIHtcbiAgICAgICAgZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKGdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgPT0gdGhpcykge1xuICAgICAgICBncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dChudWxsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG93bmVyOiB0aGlzXG4gIH0pO1xufTtcbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0YWJsZTtcbiJdfQ==
