(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

var ko = require('knockout');
var components = require('ungit-components');
var diff2html = require('diff2html').Diff2Html;

components.register('textdiff', function(args) {
  return new TextDiffViewModel(args);
});

var loadLimit = 100;

var TextDiffViewModel = function(args) {
  var self = this;
  this.filename = args.filename;
  this.repoPath = args.repoPath;
  this.server = args.server;
  this.sha1 = args.sha1;
  this.loadMoreCount = ko.observable(0);
  this.diffJson = null;
  this.loadCount = loadLimit;
  this.textDiffType = args.textDiffType;
  this.isShowingDiffs = args.isShowingDiffs;
  this.diffProgressBar = args.diffProgressBar;
  this.editState = args.editState;

  this.textDiffType.subscribe(function() {
    self.invalidateDiff();
  });
  this.patchLineList = args.patchLineList;
  this.numberOfSelectedPatchLines = 0;
  this.htmlSrc = undefined;
  this.isParsed = ko.observable(false);
}
TextDiffViewModel.prototype.updateNode = function(parentElement) {
  ko.renderTemplate('textdiff', this, {}, parentElement);
}
TextDiffViewModel.prototype.getDiffArguments = function() {
  return {
    file: this.filename,
    path: this.repoPath,
    sha1: this.sha1 ? this.sha1 : ''
  };
}

TextDiffViewModel.prototype.invalidateDiff = function(callback) {
  var self = this;
  if (this.isShowingDiffs()) {
    if (this.diffProgressBar) this.diffProgressBar.start();

    self.server.get('/diff', this.getDiffArguments() , function(err, diffs) {
      if (err) {
        if (self.diffProgressBar) self.diffProgressBar.stop();
        if (err.errorCode == 'no-such-file') {
          // The file existed before but has been removed, but we're trying to get a diff for it
          // Most likely it will just disappear with the next refresh of the staging area
          // so we just ignore the error here
          return true;
        }
        return callback ? callback(err) : null;
      }

      if (typeof diffs == 'string') {
        self.diffJson = diff2html.getJsonFromDiff(diffs);
        self.render();
      }

      if (self.diffProgressBar) self.diffProgressBar.stop();
      if (callback) callback();
    });
  } else {
    if (callback) callback();
  }
}

TextDiffViewModel.prototype.render = function() {
  if (this.diffJson.length == 0) return; // check if diffs are available (binary files do not support them)
  this.isParsed(false);

  var self = this;
  var diffJsonCopy = JSON.parse(JSON.stringify(this.diffJson)); // make a json copy
  var lineCount = 0;

  diffJsonCopy[0].blocks = diffJsonCopy[0].blocks.reduce(function(blocks, block) {
    var length = block.lines.length;
    if (lineCount < self.loadCount) {
      block.lines = block.lines.slice(0, self.loadCount - lineCount);
      blocks.push(block);
    }
    lineCount += length;
    return blocks;
  }, []);

  this.loadMoreCount(Math.min(loadLimit, Math.max(0, lineCount - this.loadCount)));

  var html;

  if (this.textDiffType() === 'sidebysidediff') {
    html = diff2html.getPrettySideBySideHtmlFromJson(diffJsonCopy);
  } else {
    html = diff2html.getPrettyHtmlFromJson(diffJsonCopy);
  }

  var index = 0;
  this.numberOfSelectedPatchLines = 0;

  // if self.patchLineList is null then patching is not avaliable so skip this expensive op.x
  if (self.patchLineList) {
    html = html.replace(/<span class="d2h-code-line-[a-z]+">(\+|\-)/g, function (match, capture) {
      if (self.patchLineList()[index] === undefined) {
        self.patchLineList()[index] = true;
      }

      return self.getPatchCheckBox(capture, index, self.patchLineList()[index++]);
    });
  }

  // ko's binding resolution is not recursive, which means below ko.bind refresh method doesn't work for
  // data bind at getPatchCheckBox that is rendered with "html" binding.
  // which is reason why manually updating the html content and refreshing kobinding to have it render...
  this.htmlSrc = html;
  this.isParsed(true);
};

TextDiffViewModel.prototype.loadMore = function(callback) {
  this.loadCount += this.loadMoreCount();
  this.render();
}

TextDiffViewModel.prototype.getPatchCheckBox = function(symbol, index, isActive) {
  if (isActive) {
    this.numberOfSelectedPatchLines++;
  }
  return '<div class="d2h-code-line-prefix"><span data-bind="visible: editState() !== \'patched\'">' + symbol + '</span><input ' + (isActive ? 'checked' : '') + ' type="checkbox" data-ta-clickable="patch-line-input" data-bind="visible: editState() === \'patched\', click: togglePatchLine.bind($data, ' + index + ')"></input>';
}

TextDiffViewModel.prototype.togglePatchLine = function(index) {
  this.patchLineList()[index] = !this.patchLineList()[index];

  if (this.patchLineList()[index]) {
    this.numberOfSelectedPatchLines++;
  } else {
    this.numberOfSelectedPatchLines--;
  }

  if (this.numberOfSelectedPatchLines === 0) {
    this.editState('none');
  }

  return true;
}

},{"diff2html":undefined,"knockout":"knockout","ungit-components":"ungit-components"}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL3RleHRkaWZmL3RleHRkaWZmLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xudmFyIGNvbXBvbmVudHMgPSByZXF1aXJlKCd1bmdpdC1jb21wb25lbnRzJyk7XG52YXIgZGlmZjJodG1sID0gcmVxdWlyZSgnZGlmZjJodG1sJykuRGlmZjJIdG1sO1xuXG5jb21wb25lbnRzLnJlZ2lzdGVyKCd0ZXh0ZGlmZicsIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgcmV0dXJuIG5ldyBUZXh0RGlmZlZpZXdNb2RlbChhcmdzKTtcbn0pO1xuXG52YXIgbG9hZExpbWl0ID0gMTAwO1xuXG52YXIgVGV4dERpZmZWaWV3TW9kZWwgPSBmdW5jdGlvbihhcmdzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5maWxlbmFtZSA9IGFyZ3MuZmlsZW5hbWU7XG4gIHRoaXMucmVwb1BhdGggPSBhcmdzLnJlcG9QYXRoO1xuICB0aGlzLnNlcnZlciA9IGFyZ3Muc2VydmVyO1xuICB0aGlzLnNoYTEgPSBhcmdzLnNoYTE7XG4gIHRoaXMubG9hZE1vcmVDb3VudCA9IGtvLm9ic2VydmFibGUoMCk7XG4gIHRoaXMuZGlmZkpzb24gPSBudWxsO1xuICB0aGlzLmxvYWRDb3VudCA9IGxvYWRMaW1pdDtcbiAgdGhpcy50ZXh0RGlmZlR5cGUgPSBhcmdzLnRleHREaWZmVHlwZTtcbiAgdGhpcy5pc1Nob3dpbmdEaWZmcyA9IGFyZ3MuaXNTaG93aW5nRGlmZnM7XG4gIHRoaXMuZGlmZlByb2dyZXNzQmFyID0gYXJncy5kaWZmUHJvZ3Jlc3NCYXI7XG4gIHRoaXMuZWRpdFN0YXRlID0gYXJncy5lZGl0U3RhdGU7XG5cbiAgdGhpcy50ZXh0RGlmZlR5cGUuc3Vic2NyaWJlKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuaW52YWxpZGF0ZURpZmYoKTtcbiAgfSk7XG4gIHRoaXMucGF0Y2hMaW5lTGlzdCA9IGFyZ3MucGF0Y2hMaW5lTGlzdDtcbiAgdGhpcy5udW1iZXJPZlNlbGVjdGVkUGF0Y2hMaW5lcyA9IDA7XG4gIHRoaXMuaHRtbFNyYyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc1BhcnNlZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xufVxuVGV4dERpZmZWaWV3TW9kZWwucHJvdG90eXBlLnVwZGF0ZU5vZGUgPSBmdW5jdGlvbihwYXJlbnRFbGVtZW50KSB7XG4gIGtvLnJlbmRlclRlbXBsYXRlKCd0ZXh0ZGlmZicsIHRoaXMsIHt9LCBwYXJlbnRFbGVtZW50KTtcbn1cblRleHREaWZmVmlld01vZGVsLnByb3RvdHlwZS5nZXREaWZmQXJndW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgZmlsZTogdGhpcy5maWxlbmFtZSxcbiAgICBwYXRoOiB0aGlzLnJlcG9QYXRoLFxuICAgIHNoYTE6IHRoaXMuc2hhMSA/IHRoaXMuc2hhMSA6ICcnXG4gIH07XG59XG5cblRleHREaWZmVmlld01vZGVsLnByb3RvdHlwZS5pbnZhbGlkYXRlRGlmZiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuaXNTaG93aW5nRGlmZnMoKSkge1xuICAgIGlmICh0aGlzLmRpZmZQcm9ncmVzc0JhcikgdGhpcy5kaWZmUHJvZ3Jlc3NCYXIuc3RhcnQoKTtcblxuICAgIHNlbGYuc2VydmVyLmdldCgnL2RpZmYnLCB0aGlzLmdldERpZmZBcmd1bWVudHMoKSAsIGZ1bmN0aW9uKGVyciwgZGlmZnMpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKHNlbGYuZGlmZlByb2dyZXNzQmFyKSBzZWxmLmRpZmZQcm9ncmVzc0Jhci5zdG9wKCk7XG4gICAgICAgIGlmIChlcnIuZXJyb3JDb2RlID09ICduby1zdWNoLWZpbGUnKSB7XG4gICAgICAgICAgLy8gVGhlIGZpbGUgZXhpc3RlZCBiZWZvcmUgYnV0IGhhcyBiZWVuIHJlbW92ZWQsIGJ1dCB3ZSdyZSB0cnlpbmcgdG8gZ2V0IGEgZGlmZiBmb3IgaXRcbiAgICAgICAgICAvLyBNb3N0IGxpa2VseSBpdCB3aWxsIGp1c3QgZGlzYXBwZWFyIHdpdGggdGhlIG5leHQgcmVmcmVzaCBvZiB0aGUgc3RhZ2luZyBhcmVhXG4gICAgICAgICAgLy8gc28gd2UganVzdCBpZ25vcmUgdGhlIGVycm9yIGhlcmVcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhlcnIpIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkaWZmcyA9PSAnc3RyaW5nJykge1xuICAgICAgICBzZWxmLmRpZmZKc29uID0gZGlmZjJodG1sLmdldEpzb25Gcm9tRGlmZihkaWZmcyk7XG4gICAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmRpZmZQcm9ncmVzc0Jhcikgc2VsZi5kaWZmUHJvZ3Jlc3NCYXIuc3RvcCgpO1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgfVxufVxuXG5UZXh0RGlmZlZpZXdNb2RlbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmRpZmZKc29uLmxlbmd0aCA9PSAwKSByZXR1cm47IC8vIGNoZWNrIGlmIGRpZmZzIGFyZSBhdmFpbGFibGUgKGJpbmFyeSBmaWxlcyBkbyBub3Qgc3VwcG9ydCB0aGVtKVxuICB0aGlzLmlzUGFyc2VkKGZhbHNlKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBkaWZmSnNvbkNvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuZGlmZkpzb24pKTsgLy8gbWFrZSBhIGpzb24gY29weVxuICB2YXIgbGluZUNvdW50ID0gMDtcblxuICBkaWZmSnNvbkNvcHlbMF0uYmxvY2tzID0gZGlmZkpzb25Db3B5WzBdLmJsb2Nrcy5yZWR1Y2UoZnVuY3Rpb24oYmxvY2tzLCBibG9jaykge1xuICAgIHZhciBsZW5ndGggPSBibG9jay5saW5lcy5sZW5ndGg7XG4gICAgaWYgKGxpbmVDb3VudCA8IHNlbGYubG9hZENvdW50KSB7XG4gICAgICBibG9jay5saW5lcyA9IGJsb2NrLmxpbmVzLnNsaWNlKDAsIHNlbGYubG9hZENvdW50IC0gbGluZUNvdW50KTtcbiAgICAgIGJsb2Nrcy5wdXNoKGJsb2NrKTtcbiAgICB9XG4gICAgbGluZUNvdW50ICs9IGxlbmd0aDtcbiAgICByZXR1cm4gYmxvY2tzO1xuICB9LCBbXSk7XG5cbiAgdGhpcy5sb2FkTW9yZUNvdW50KE1hdGgubWluKGxvYWRMaW1pdCwgTWF0aC5tYXgoMCwgbGluZUNvdW50IC0gdGhpcy5sb2FkQ291bnQpKSk7XG5cbiAgdmFyIGh0bWw7XG5cbiAgaWYgKHRoaXMudGV4dERpZmZUeXBlKCkgPT09ICdzaWRlYnlzaWRlZGlmZicpIHtcbiAgICBodG1sID0gZGlmZjJodG1sLmdldFByZXR0eVNpZGVCeVNpZGVIdG1sRnJvbUpzb24oZGlmZkpzb25Db3B5KTtcbiAgfSBlbHNlIHtcbiAgICBodG1sID0gZGlmZjJodG1sLmdldFByZXR0eUh0bWxGcm9tSnNvbihkaWZmSnNvbkNvcHkpO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gMDtcbiAgdGhpcy5udW1iZXJPZlNlbGVjdGVkUGF0Y2hMaW5lcyA9IDA7XG5cbiAgLy8gaWYgc2VsZi5wYXRjaExpbmVMaXN0IGlzIG51bGwgdGhlbiBwYXRjaGluZyBpcyBub3QgYXZhbGlhYmxlIHNvIHNraXAgdGhpcyBleHBlbnNpdmUgb3AueFxuICBpZiAoc2VsZi5wYXRjaExpbmVMaXN0KSB7XG4gICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvPHNwYW4gY2xhc3M9XCJkMmgtY29kZS1saW5lLVthLXpdK1wiPihcXCt8XFwtKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGNhcHR1cmUpIHtcbiAgICAgIGlmIChzZWxmLnBhdGNoTGluZUxpc3QoKVtpbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmLnBhdGNoTGluZUxpc3QoKVtpbmRleF0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5nZXRQYXRjaENoZWNrQm94KGNhcHR1cmUsIGluZGV4LCBzZWxmLnBhdGNoTGluZUxpc3QoKVtpbmRleCsrXSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBrbydzIGJpbmRpbmcgcmVzb2x1dGlvbiBpcyBub3QgcmVjdXJzaXZlLCB3aGljaCBtZWFucyBiZWxvdyBrby5iaW5kIHJlZnJlc2ggbWV0aG9kIGRvZXNuJ3Qgd29yayBmb3JcbiAgLy8gZGF0YSBiaW5kIGF0IGdldFBhdGNoQ2hlY2tCb3ggdGhhdCBpcyByZW5kZXJlZCB3aXRoIFwiaHRtbFwiIGJpbmRpbmcuXG4gIC8vIHdoaWNoIGlzIHJlYXNvbiB3aHkgbWFudWFsbHkgdXBkYXRpbmcgdGhlIGh0bWwgY29udGVudCBhbmQgcmVmcmVzaGluZyBrb2JpbmRpbmcgdG8gaGF2ZSBpdCByZW5kZXIuLi5cbiAgdGhpcy5odG1sU3JjID0gaHRtbDtcbiAgdGhpcy5pc1BhcnNlZCh0cnVlKTtcbn07XG5cblRleHREaWZmVmlld01vZGVsLnByb3RvdHlwZS5sb2FkTW9yZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHRoaXMubG9hZENvdW50ICs9IHRoaXMubG9hZE1vcmVDb3VudCgpO1xuICB0aGlzLnJlbmRlcigpO1xufVxuXG5UZXh0RGlmZlZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0UGF0Y2hDaGVja0JveCA9IGZ1bmN0aW9uKHN5bWJvbCwgaW5kZXgsIGlzQWN0aXZlKSB7XG4gIGlmIChpc0FjdGl2ZSkge1xuICAgIHRoaXMubnVtYmVyT2ZTZWxlY3RlZFBhdGNoTGluZXMrKztcbiAgfVxuICByZXR1cm4gJzxkaXYgY2xhc3M9XCJkMmgtY29kZS1saW5lLXByZWZpeFwiPjxzcGFuIGRhdGEtYmluZD1cInZpc2libGU6IGVkaXRTdGF0ZSgpICE9PSBcXCdwYXRjaGVkXFwnXCI+JyArIHN5bWJvbCArICc8L3NwYW4+PGlucHV0ICcgKyAoaXNBY3RpdmUgPyAnY2hlY2tlZCcgOiAnJykgKyAnIHR5cGU9XCJjaGVja2JveFwiIGRhdGEtdGEtY2xpY2thYmxlPVwicGF0Y2gtbGluZS1pbnB1dFwiIGRhdGEtYmluZD1cInZpc2libGU6IGVkaXRTdGF0ZSgpID09PSBcXCdwYXRjaGVkXFwnLCBjbGljazogdG9nZ2xlUGF0Y2hMaW5lLmJpbmQoJGRhdGEsICcgKyBpbmRleCArICcpXCI+PC9pbnB1dD4nO1xufVxuXG5UZXh0RGlmZlZpZXdNb2RlbC5wcm90b3R5cGUudG9nZ2xlUGF0Y2hMaW5lID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdGhpcy5wYXRjaExpbmVMaXN0KClbaW5kZXhdID0gIXRoaXMucGF0Y2hMaW5lTGlzdCgpW2luZGV4XTtcblxuICBpZiAodGhpcy5wYXRjaExpbmVMaXN0KClbaW5kZXhdKSB7XG4gICAgdGhpcy5udW1iZXJPZlNlbGVjdGVkUGF0Y2hMaW5lcysrO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubnVtYmVyT2ZTZWxlY3RlZFBhdGNoTGluZXMtLTtcbiAgfVxuXG4gIGlmICh0aGlzLm51bWJlck9mU2VsZWN0ZWRQYXRjaExpbmVzID09PSAwKSB7XG4gICAgdGhpcy5lZGl0U3RhdGUoJ25vbmUnKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuIl19
